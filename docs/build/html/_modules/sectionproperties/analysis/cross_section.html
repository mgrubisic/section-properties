

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sectionproperties.analysis.cross_section &mdash; sectionproperties 1.0.6 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> sectionproperties
          

          
          </a>

          
            
            
              <div class="version">
                1.0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/structure.html">Structure of an Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/geom_mesh.html">Creating a Geometry, Mesh and Material Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/analysis.html">Running an Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/post.html">Viewing the Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/api.html">Python API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/theory.html">Theoretical Background</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sectionproperties</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>sectionproperties.analysis.cross_section</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sectionproperties.analysis.cross_section</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csc_matrix</span><span class="p">,</span> <span class="n">coo_matrix</span><span class="p">,</span> <span class="n">linalg</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">brentq</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.tri</span> <span class="k">as</span> <span class="nn">tri</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span>
<span class="kn">import</span> <span class="nn">meshpy.triangle</span> <span class="k">as</span> <span class="nn">triangle</span>
<span class="kn">import</span> <span class="nn">sectionproperties.pre.pre</span> <span class="k">as</span> <span class="nn">pre</span>
<span class="kn">import</span> <span class="nn">sectionproperties.analysis.fea</span> <span class="k">as</span> <span class="nn">fea</span>
<span class="kn">import</span> <span class="nn">sectionproperties.analysis.solver</span> <span class="k">as</span> <span class="nn">solver</span>
<span class="kn">import</span> <span class="nn">sectionproperties.post.post</span> <span class="k">as</span> <span class="nn">post</span>


<div class="viewcode-block" id="CrossSection"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.CrossSection">[docs]</a><span class="k">class</span> <span class="nc">CrossSection</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for structural cross-sections.</span>

<span class="sd">    Stores the finite element geometry, mesh and material information and provides methods to</span>
<span class="sd">    compute the cross-section properties. The element type used in this program is the six-noded</span>
<span class="sd">    quadratic triangular element.</span>

<span class="sd">    The constructor extracts information from the provided mesh object and creates and stores the</span>
<span class="sd">    corresponding Tri6 finite element objects.</span>

<span class="sd">    :param geometry: Cross-section geometry object used to generate the mesh</span>
<span class="sd">    :type geometry: :class:`~sectionproperties.pre.sections.Geometry`</span>
<span class="sd">    :param mesh: Mesh object returned by meshpy</span>
<span class="sd">    :type mesh: :class:`meshpy.triangle.MeshInfo`</span>
<span class="sd">    :param materials: A list of material properties corresponding to various regions in the</span>
<span class="sd">        geometry and mesh. Note that if materials are specified, the number of material objects</span>
<span class="sd">        ust equal the number of regions in the geometry. If no materials are specified, only a</span>
<span class="sd">        purely geometric analysis can take place, and all regions will be assigned a default</span>
<span class="sd">        material with an elastic modulus and yield strength equal to 1, and a Poisson&#39;s ratio</span>
<span class="sd">        equal to 0.</span>
<span class="sd">    :type materials: list[:class:`~sectionproperties.pre.pre.Material`]</span>
<span class="sd">    :param bool time_info: If set to True, a detailed description of the computation and the time</span>
<span class="sd">        cost is printed to the terminal.</span>

<span class="sd">    The following example creates a :class:`~sectionproperties.analysis.cross_section.CrossSection`</span>
<span class="sd">    object of a 100D x 50W rectangle using a mesh size of 5::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>
<span class="sd">        from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">        geometry = sections.RectangularSection(d=100, b=50)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5])</span>
<span class="sd">        section = CrossSection(geometry, mesh)</span>

<span class="sd">    The following example creates a 100D x 50W rectangle, with the top half of the section</span>
<span class="sd">    comprised of timber and the bottom half steel. The timber section is meshed with a maximum area</span>
<span class="sd">    of 10 and the steel section mesh with a maximum area of 5::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>
<span class="sd">        from sectionproperties.pre.pre import Material</span>
<span class="sd">        from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">        geom_steel = sections.RectangularSection(d=50, b=50)</span>
<span class="sd">        geom_timber = sections.RectangularSection(d=50, b=50, shift=[0, 50])</span>
<span class="sd">        geometry = sections.MergedSection([geom_steel, geom_timber])</span>
<span class="sd">        geometry.clean_geometry()</span>

<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5, 10])</span>

<span class="sd">        steel = Material(name=&#39;Steel&#39;, elastic_modulus=200e3, poissons_ratio=0.3,</span>
<span class="sd">            yield_strength=250, color=&#39;grey&#39;</span>
<span class="sd">        )</span>
<span class="sd">        timber = Material(name=&#39;Timber&#39;, elastic_modulus=8e3, poissons_ratio=0.35,</span>
<span class="sd">            yield_strength=20, color=&#39;burlywood&#39;</span>
<span class="sd">        )</span>

<span class="sd">        section = CrossSection(geometry, mesh, [steel, timber])</span>
<span class="sd">        section.plot_mesh(materials=True, alpha=0.5)</span>

<span class="sd">    :cvar elements: List of finite element objects describing the cross-section mesh</span>
<span class="sd">    :vartype elements: list[:class:`~sectionproperties.analysis.fea.Tri6`]</span>
<span class="sd">    :cvar int num_nodes: Number of nodes in the finite element mesh</span>
<span class="sd">    :cvar geometry: Cross-section geometry object used to generate the mesh</span>
<span class="sd">    :vartype geometry: :class:`~sectionproperties.pre.sections.Geometry`</span>
<span class="sd">    :cvar mesh: Mesh object returned by meshpy</span>
<span class="sd">    :vartype mesh: :class:`meshpy.triangle.MeshInfo`</span>
<span class="sd">    :cvar mesh_nodes: Array of node coordinates from the mesh</span>
<span class="sd">    :vartype mesh_nodes: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar mesh_elements: Array of connectivities from the mesh</span>
<span class="sd">    :vartype mesh_elements: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar mesh_attributes: Array of attributes from the mesh</span>
<span class="sd">    :vartype mesh_attributes: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar materials: List of materials</span>
<span class="sd">    :type materials: list[:class:`~sectionproperties.pre.pre.Material`]</span>
<span class="sd">    :cvar material_groups: List of objects containing the elements in each defined material</span>
<span class="sd">    :type materials_groups: list[:class:`~sectionproperties.pre.pre.MaterialGroup`]</span>
<span class="sd">    :cvar section_props: Class to store calculated section properties</span>
<span class="sd">    :vartype section_props: :class:`~sectionproperties.analysis.cross_section.SectionProperties`</span>

<span class="sd">    :raises AssertionError: If the number of materials does not equal the number of regions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">materials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_info</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the CrossSection class.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span>  <span class="c1"># save geometry data</span>

            <span class="c1"># extract mesh data</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">element_attributes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

            <span class="c1"># swap mid-node order to retain node ordering consistency</span>
            <span class="n">elements</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

            <span class="c1"># save total number of nodes in mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

            <span class="c1"># initialise material_sections variable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># if materials are specified, check that the right number of material properties are</span>
            <span class="c1"># specified and then populate material_groups list</span>
            <span class="k">if</span> <span class="n">materials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Number of materials (</span><span class="si">{0}</span><span class="s2">), &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">materials</span><span class="p">))</span>
                <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;should match the number of regions (</span><span class="si">{0}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">materials</span><span class="p">)</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">str</span>

                <span class="c1"># add a MaterialGroup object to the material_groups list for each uniquely</span>
                <span class="c1"># encountered material</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">material</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">materials</span><span class="p">):</span>
                    <span class="c1"># add the first material to the list</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MaterialGroup</span><span class="p">(</span><span class="n">material</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># if the material hasn&#39;t been encountered</span>
                        <span class="k">if</span> <span class="n">material</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">materials</span><span class="p">[:</span><span class="n">i</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MaterialGroup</span><span class="p">(</span><span class="n">material</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">))</span>
            <span class="c1"># if there are no materials defined, add only the default material</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">default_material</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">Material</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MaterialGroup</span><span class="p">(</span><span class="n">default_material</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">materials</span> <span class="o">=</span> <span class="n">materials</span>  <span class="c1"># save the input materials list</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialise list holding all element objects</span>

            <span class="c1"># build the mesh one element at a time</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x3</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y3</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x4</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y4</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x5</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">4</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y5</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">4</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x6</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">5</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y6</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">5</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># create a list containing the vertex and mid-node coordinates</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="n">x5</span><span class="p">,</span> <span class="n">x6</span><span class="p">],</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">y4</span><span class="p">,</span> <span class="n">y5</span><span class="p">,</span> <span class="n">y6</span><span class="p">]])</span>

                <span class="c1"># if materials are specified, get the material</span>
                <span class="k">if</span> <span class="n">materials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># get attribute index of current element</span>
                    <span class="n">att_el</span> <span class="o">=</span> <span class="n">attributes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                    <span class="c1"># fetch the material</span>
                    <span class="n">material</span> <span class="o">=</span> <span class="n">materials</span><span class="p">[</span><span class="n">att_el</span><span class="p">]</span>
                <span class="c1"># if there are no materials specified, use a default material</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">material</span> <span class="o">=</span> <span class="n">default_material</span>

                <span class="c1"># add tri6 elements to the mesh</span>
                <span class="n">new_element</span> <span class="o">=</span> <span class="n">fea</span><span class="o">.</span><span class="n">Tri6</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span> <span class="n">material</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_element</span><span class="p">)</span>

                <span class="c1"># add element to relevant MaterialGroup</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">material</span> <span class="ow">is</span> <span class="n">group</span><span class="o">.</span><span class="n">material</span><span class="p">:</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">add_element</span><span class="p">(</span><span class="n">new_element</span><span class="p">)</span>
                        <span class="k">break</span>

            <span class="c1"># save mesh input</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span> <span class="o">=</span> <span class="n">nodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_elements</span> <span class="o">=</span> <span class="n">elements</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_attributes</span> <span class="o">=</span> <span class="n">attributes</span>

            <span class="c1"># initialise class storing section properties</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span> <span class="o">=</span> <span class="n">SectionProperties</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Initialising the CrossSection class...&quot;</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">init</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">init</span><span class="p">()</span>

<div class="viewcode-block" id="CrossSection.calculate_geometric_properties"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.CrossSection.calculate_geometric_properties">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_geometric_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_info</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the geometric properties of the cross-section and stores them in the</span>
<span class="sd">        :class:`~sectionproperties.analysis.cross_section.SectionProperties` object contained in</span>
<span class="sd">        the ``section_props`` class variable.</span>

<span class="sd">        :param bool time_info: If set to True, a detailed description of the computation and the</span>
<span class="sd">            time cost is printed to the terminal.</span>

<span class="sd">        The following geometric section properties are calculated:</span>

<span class="sd">        * Cross-sectional area</span>
<span class="sd">        * Cross-sectional perimeter</span>
<span class="sd">        * Modulus weighted area (axial rigidity)</span>
<span class="sd">        * First moments of area</span>
<span class="sd">        * Second moments of area about the global axis</span>
<span class="sd">        * Second moments of area about the centroidal axis</span>
<span class="sd">        * Elastic centroid</span>
<span class="sd">        * Centroidal section moduli</span>
<span class="sd">        * Radii of gyration</span>
<span class="sd">        * Principal axis properties</span>

<span class="sd">        If materials are specified for the cross-section, the moments of area and section moduli</span>
<span class="sd">        are elastic modulus weighted.</span>

<span class="sd">        The following example demonstrates the use of this method::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">calculate_geom</span><span class="p">():</span>
            <span class="c1"># initialise properties</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ga</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_g</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_g</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_g</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># caclulate perimeter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">calculate_perimeter</span><span class="p">()</span>

            <span class="c1"># calculate global geometric properties</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">ixx_g</span><span class="p">,</span> <span class="n">iyy_g</span><span class="p">,</span> <span class="n">ixy_g</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">geometric_properties</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span> <span class="o">+=</span> <span class="n">area</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span> <span class="o">+=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ga</span> <span class="o">+=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">g</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qx</span> <span class="o">+=</span> <span class="n">qx</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qy</span> <span class="o">+=</span> <span class="n">qy</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_g</span> <span class="o">+=</span> <span class="n">ixx_g</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_g</span> <span class="o">+=</span> <span class="n">iyy_g</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_g</span> <span class="o">+=</span> <span class="n">ixy_g</span> <span class="o">*</span> <span class="n">e</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">nu_eff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ga</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">calculate_elastic_centroid</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">calculate_centroidal_properties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Calculating geometric section properties...&quot;</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">calculate_geom</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">calculate_geom</span><span class="p">()</span></div>

<div class="viewcode-block" id="CrossSection.calculate_warping_properties"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.CrossSection.calculate_warping_properties">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_warping_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">solver_type</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates all the warping properties of the cross-section and stores them in the</span>
<span class="sd">        :class:`~sectionproperties.analysis.cross_section.SectionProperties` object contained in</span>
<span class="sd">        the ``section_props`` class variable.</span>

<span class="sd">        :param bool time_info: If set to True, a detailed description of the computation and the</span>
<span class="sd">            time cost is printed to the terminal.</span>
<span class="sd">        :param string solver_type: Solver used for solving systems of linear equations, either</span>
<span class="sd">            using the *&#39;direct&#39;* method or *&#39;cgs&#39;* iterative method</span>

<span class="sd">        The following warping section properties are calculated:</span>

<span class="sd">        * Torsion constant</span>
<span class="sd">        * Shear centre</span>
<span class="sd">        * Shear area</span>
<span class="sd">        * Warping constant</span>
<span class="sd">        * Monosymmetry constant</span>

<span class="sd">        If materials are specified, the values calculated for the torsion constant, warping</span>
<span class="sd">        constant and shear area are elastic modulus weighted.</span>

<span class="sd">        Note that the geometric properties must be calculated first for the calculation of the</span>
<span class="sd">        warping properties to be correct::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>

<span class="sd">        :raises RuntimeError: If the geometric properties have not been</span>
<span class="sd">            calculated prior to calling this method</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that a geometric analysis has been performed</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span><span class="p">]:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Cacluate geometric properties before performing a warping analysis.&quot;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="c1"># create a new CrossSection with the origin shifted to the centroid for calculation of the</span>
        <span class="c1"># warping properties such that the Lagrangian multiplier approach can be utilised</span>
        <span class="n">warping_section</span> <span class="o">=</span> <span class="n">CrossSection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">)</span>

        <span class="c1"># shift the coordinates of each element N.B. the mesh class attribute remains unshifted!</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">warping_section</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="n">el</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span>
            <span class="n">el</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span>

        <span class="c1"># assemble stiffness matrix and load vector for warping function</span>
        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Assembing </span><span class="si">{0}</span><span class="s2">x</span><span class="si">{0}</span><span class="s2"> stiffness matrix and load vector...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k_lg</span><span class="p">,</span> <span class="n">f_torsion</span><span class="p">)</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">warping_section</span><span class="o">.</span><span class="n">assemble_torsion</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k_lg</span><span class="p">,</span> <span class="n">f_torsion</span><span class="p">)</span> <span class="o">=</span> <span class="n">warping_section</span><span class="o">.</span><span class="n">assemble_torsion</span><span class="p">()</span>

        <span class="c1"># ILU decomposition of stiffness matrices</span>
        <span class="k">def</span> <span class="nf">ilu_decomp</span><span class="p">():</span>
            <span class="c1"># ILU decomposition on regular stiffness matrix</span>
            <span class="n">k_precond</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">),</span> <span class="n">linalg</span><span class="o">.</span><span class="n">spilu</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span>
            <span class="p">)</span>

            <span class="c1"># ILU decomposition on Lagrangian stiffness matrix</span>
            <span class="n">k_lg_precond</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">linalg</span><span class="o">.</span><span class="n">spilu</span><span class="p">(</span><span class="n">k_lg</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">k_precond</span><span class="p">,</span> <span class="n">k_lg_precond</span><span class="p">)</span>

        <span class="c1"># if the cgs method is used, perform ILU decomposition</span>
        <span class="k">if</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s1">&#39;cgs&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Performing ILU decomposition on the stiffness matrices...&quot;</span>
                <span class="p">(</span><span class="n">k_precond</span><span class="p">,</span> <span class="n">k_lg_precond</span><span class="p">)</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">ilu_decomp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">k_precond</span><span class="p">,</span> <span class="n">k_lg_precond</span><span class="p">)</span> <span class="o">=</span> <span class="n">ilu_decomp</span><span class="p">()</span>

        <span class="c1"># solve for warping function</span>
        <span class="k">def</span> <span class="nf">solve_warping</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s1">&#39;cgs&#39;</span><span class="p">:</span>
                <span class="n">omega</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve_cgs</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">f_torsion</span><span class="p">,</span> <span class="n">k_precond</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s1">&#39;direct&#39;</span><span class="p">:</span>
                <span class="n">omega</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve_direct</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">f_torsion</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">omega</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Solving for the warping function using the </span><span class="si">{0}</span><span class="s2"> solver...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">solver_type</span><span class="p">)</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">solve_warping</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="n">solve_warping</span><span class="p">()</span>

        <span class="c1"># save the warping function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span>

        <span class="c1"># determine the torsion constant</span>
        <span class="k">def</span> <span class="nf">j_func</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">-</span>
                <span class="n">omega</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">omega</span><span class="p">)))</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Computing the torsion constant...&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">j_func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">j_func</span><span class="p">()</span>

        <span class="c1"># assemble shear function load vectors</span>
        <span class="k">def</span> <span class="nf">assemble_shear_load</span><span class="p">():</span>
            <span class="n">f_psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="n">f_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">warping_section</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="p">(</span><span class="n">f_psi_el</span><span class="p">,</span> <span class="n">f_phi_el</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">shear_load_vectors</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">nu_eff</span><span class="p">)</span>
                <span class="n">f_psi</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f_psi_el</span>
                <span class="n">f_phi</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f_phi_el</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">f_psi</span><span class="p">,</span> <span class="n">f_phi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Assembling shear function load vectors...&quot;</span>
            <span class="p">(</span><span class="n">f_psi</span><span class="p">,</span> <span class="n">f_phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">assemble_shear_load</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">f_psi</span><span class="p">,</span> <span class="n">f_phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">assemble_shear_load</span><span class="p">()</span>

        <span class="c1"># solve for shear functions psi and phi</span>
        <span class="k">def</span> <span class="nf">solve_shear_functions</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s1">&#39;cgs&#39;</span><span class="p">:</span>
                <span class="n">psi_shear</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve_cgs_lagrange</span><span class="p">(</span><span class="n">k_lg</span><span class="p">,</span> <span class="n">f_psi</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">k_lg_precond</span><span class="p">)</span>
                <span class="n">phi_shear</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve_cgs_lagrange</span><span class="p">(</span><span class="n">k_lg</span><span class="p">,</span> <span class="n">f_phi</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">k_lg_precond</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s1">&#39;direct&#39;</span><span class="p">:</span>
                <span class="n">psi_shear</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve_direct_lagrange</span><span class="p">(</span><span class="n">k_lg</span><span class="p">,</span> <span class="n">f_psi</span><span class="p">)</span>
                <span class="n">phi_shear</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve_direct_lagrange</span><span class="p">(</span><span class="n">k_lg</span><span class="p">,</span> <span class="n">f_phi</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">psi_shear</span><span class="p">,</span> <span class="n">phi_shear</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Solving for the shear functions using the </span><span class="si">{0}</span><span class="s2"> solver...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">solver_type</span><span class="p">)</span>
            <span class="p">(</span><span class="n">psi_shear</span><span class="p">,</span> <span class="n">phi_shear</span><span class="p">)</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">solve_shear_functions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">psi_shear</span><span class="p">,</span> <span class="n">phi_shear</span><span class="p">)</span> <span class="o">=</span> <span class="n">solve_shear_functions</span><span class="p">()</span>

        <span class="c1"># save the shear functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">psi_shear</span> <span class="o">=</span> <span class="n">psi_shear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi_shear</span> <span class="o">=</span> <span class="n">phi_shear</span>

        <span class="c1"># assemble shear centre and warping moment integrals</span>
        <span class="k">def</span> <span class="nf">assemle_sc_warping_integrals</span><span class="p">():</span>
            <span class="n">sc_xint</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">sc_yint</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">q_omega</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i_omega</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i_xomega</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i_yomega</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">warping_section</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="p">(</span><span class="n">sc_xint_el</span><span class="p">,</span> <span class="n">sc_yint_el</span><span class="p">,</span> <span class="n">q_omega_el</span><span class="p">,</span> <span class="n">i_omega_el</span><span class="p">,</span> <span class="n">i_xomega_el</span><span class="p">,</span>
                 <span class="n">i_yomega_el</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">shear_warping_integrals</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span><span class="p">,</span> <span class="n">omega</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="n">sc_xint</span> <span class="o">+=</span> <span class="n">sc_xint_el</span>
                <span class="n">sc_yint</span> <span class="o">+=</span> <span class="n">sc_yint_el</span>
                <span class="n">q_omega</span> <span class="o">+=</span> <span class="n">q_omega_el</span>
                <span class="n">i_omega</span> <span class="o">+=</span> <span class="n">i_omega_el</span>
                <span class="n">i_xomega</span> <span class="o">+=</span> <span class="n">i_xomega_el</span>
                <span class="n">i_yomega</span> <span class="o">+=</span> <span class="n">i_yomega_el</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">sc_xint</span><span class="p">,</span> <span class="n">sc_yint</span><span class="p">,</span> <span class="n">q_omega</span><span class="p">,</span> <span class="n">i_omega</span><span class="p">,</span> <span class="n">i_xomega</span><span class="p">,</span> <span class="n">i_yomega</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Assembling shear centre and warping moment integrals...&quot;</span>
            <span class="p">(</span><span class="n">sc_xint</span><span class="p">,</span> <span class="n">sc_yint</span><span class="p">,</span> <span class="n">q_omega</span><span class="p">,</span> <span class="n">i_omega</span><span class="p">,</span> <span class="n">i_xomega</span><span class="p">,</span> <span class="n">i_yomega</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">assemle_sc_warping_integrals</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">sc_xint</span><span class="p">,</span> <span class="n">sc_yint</span><span class="p">,</span> <span class="n">q_omega</span><span class="p">,</span> <span class="n">i_omega</span><span class="p">,</span> <span class="n">i_xomega</span><span class="p">,</span> <span class="n">i_yomega</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">assemle_sc_warping_integrals</span><span class="p">())</span>

        <span class="c1"># calculate shear centres</span>
        <span class="k">def</span> <span class="nf">shear_centres</span><span class="p">():</span>
            <span class="c1"># calculate shear centres (elasticity approach)</span>
            <span class="n">Delta_s</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">nu_eff</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">-</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">x_se</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">Delta_s</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">nu_eff</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span>
                                  <span class="n">sc_xint</span><span class="p">)</span> <span class="o">-</span> <span class="n">f_torsion</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi_shear</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">y_se</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">Delta_s</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">nu_eff</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span>
                                  <span class="n">sc_yint</span><span class="p">)</span> <span class="o">+</span> <span class="n">f_torsion</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi_shear</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="n">x11_se</span><span class="p">,</span> <span class="n">y22_se</span><span class="p">)</span> <span class="o">=</span> <span class="n">fea</span><span class="o">.</span><span class="n">principal_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">x_se</span><span class="p">,</span> <span class="n">y_se</span><span class="p">)</span>

            <span class="c1"># calculate shear centres (Trefftz&#39;s approach)</span>
            <span class="n">x_st</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">*</span> <span class="n">i_xomega</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">*</span> <span class="n">i_yomega</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">-</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">y_st</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">*</span> <span class="n">i_xomega</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">*</span> <span class="n">i_yomega</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">-</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">Delta_s</span><span class="p">,</span> <span class="n">x_se</span><span class="p">,</span> <span class="n">y_se</span><span class="p">,</span> <span class="n">x11_se</span><span class="p">,</span> <span class="n">y22_se</span><span class="p">,</span> <span class="n">x_st</span><span class="p">,</span> <span class="n">y_st</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Calculating shear centres...&quot;</span>
            <span class="p">(</span><span class="n">Delta_s</span><span class="p">,</span> <span class="n">x_se</span><span class="p">,</span> <span class="n">y_se</span><span class="p">,</span> <span class="n">x11_se</span><span class="p">,</span> <span class="n">y22_se</span><span class="p">,</span> <span class="n">x_st</span><span class="p">,</span> <span class="n">y_st</span><span class="p">)</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span>
                <span class="n">text</span><span class="p">,</span> <span class="n">shear_centres</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">Delta_s</span><span class="p">,</span> <span class="n">x_se</span><span class="p">,</span> <span class="n">y_se</span><span class="p">,</span> <span class="n">x11_se</span><span class="p">,</span> <span class="n">y22_se</span><span class="p">,</span> <span class="n">x_st</span><span class="p">,</span> <span class="n">y_st</span><span class="p">)</span> <span class="o">=</span> <span class="n">shear_centres</span><span class="p">()</span>

        <span class="c1"># save shear centres</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">Delta_s</span> <span class="o">=</span> <span class="n">Delta_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_se</span> <span class="o">=</span> <span class="n">x_se</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y_se</span> <span class="o">=</span> <span class="n">y_se</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x11_se</span> <span class="o">=</span> <span class="n">x11_se</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y22_se</span> <span class="o">=</span> <span class="n">y22_se</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_st</span> <span class="o">=</span> <span class="n">x_st</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y_st</span> <span class="o">=</span> <span class="n">y_st</span>

        <span class="c1"># calculate warping constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">i_omega</span> <span class="o">-</span> <span class="n">q_omega</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span> <span class="o">-</span> <span class="n">y_se</span> <span class="o">*</span> <span class="n">i_xomega</span> <span class="o">+</span> <span class="n">x_se</span> <span class="o">*</span> <span class="n">i_yomega</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">assemble_shear_deformation</span><span class="p">():</span>
            <span class="c1"># assemble shear deformation coefficients</span>
            <span class="n">kappa_x</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">kappa_y</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">kappa_xy</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">warping_section</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="p">(</span><span class="n">kappa_x_el</span><span class="p">,</span> <span class="n">kappa_y_el</span><span class="p">,</span> <span class="n">kappa_xy_el</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">shear_coefficients</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span><span class="p">,</span> <span class="n">psi_shear</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">],</span> <span class="n">phi_shear</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">nu_eff</span>
                <span class="p">)</span>

                <span class="n">kappa_x</span> <span class="o">+=</span> <span class="n">kappa_x_el</span>
                <span class="n">kappa_y</span> <span class="o">+=</span> <span class="n">kappa_y_el</span>
                <span class="n">kappa_xy</span> <span class="o">+=</span> <span class="n">kappa_xy_el</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">kappa_x</span><span class="p">,</span> <span class="n">kappa_y</span><span class="p">,</span> <span class="n">kappa_xy</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Assembling shear deformation coefficients...&quot;</span>
            <span class="p">(</span><span class="n">kappa_x</span><span class="p">,</span> <span class="n">kappa_y</span><span class="p">,</span> <span class="n">kappa_xy</span><span class="p">)</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">assemble_shear_deformation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">kappa_x</span><span class="p">,</span> <span class="n">kappa_y</span><span class="p">,</span> <span class="n">kappa_xy</span><span class="p">)</span> <span class="o">=</span> <span class="n">assemble_shear_deformation</span><span class="p">()</span>

        <span class="c1"># calculate shear areas wrt global axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">A_sx</span> <span class="o">=</span> <span class="n">Delta_s</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">kappa_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">A_sy</span> <span class="o">=</span> <span class="n">Delta_s</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">kappa_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">A_sxy</span> <span class="o">=</span> <span class="n">Delta_s</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">kappa_xy</span>

        <span class="c1"># calculate shear areas wrt principal bending axis:</span>
        <span class="n">alpha_xx</span> <span class="o">=</span> <span class="n">kappa_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">Delta_s</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">alpha_yy</span> <span class="o">=</span> <span class="n">kappa_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">Delta_s</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">alpha_xy</span> <span class="o">=</span> <span class="n">kappa_xy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">Delta_s</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="c1"># rotate the tensor by the principal axis angle</span>
        <span class="n">phi_rad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_rad</span><span class="p">),</span>  <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_rad</span><span class="p">)],</span>
            <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_rad</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_rad</span><span class="p">)]</span>
        <span class="p">])</span>

        <span class="n">rotatedAlpha</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">alpha_xx</span><span class="p">,</span> <span class="n">alpha_xy</span><span class="p">],</span>
            <span class="p">[</span><span class="n">alpha_xy</span><span class="p">,</span> <span class="n">alpha_yy</span><span class="p">]</span>
        <span class="p">]))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>

        <span class="c1"># recalculate the shear area based on the rotated alpha value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">A_s11</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">rotatedAlpha</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">A_s22</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">rotatedAlpha</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># calculate the monosymmetry consants</span>
        <span class="k">def</span> <span class="nf">calculate_monosymmetry_integrals</span><span class="p">():</span>
            <span class="n">int_x</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">int_y</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">int_11</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">int_22</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">warping_section</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="p">(</span><span class="n">int_x_el</span><span class="p">,</span> <span class="n">int_y_el</span><span class="p">,</span> <span class="n">int_11_el</span><span class="p">,</span> <span class="n">int_22_el</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">monosymmetry_integrals</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span>
                <span class="p">)</span>

                <span class="n">int_x</span> <span class="o">+=</span> <span class="n">int_x_el</span>
                <span class="n">int_y</span> <span class="o">+=</span> <span class="n">int_y_el</span>
                <span class="n">int_11</span> <span class="o">+=</span> <span class="n">int_11_el</span>
                <span class="n">int_22</span> <span class="o">+=</span> <span class="n">int_22_el</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">int_x</span><span class="p">,</span> <span class="n">int_y</span><span class="p">,</span> <span class="n">int_11</span><span class="p">,</span> <span class="n">int_22</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Assembling monosymmetry integrals...&quot;</span>
            <span class="p">(</span><span class="n">int_x</span><span class="p">,</span> <span class="n">int_y</span><span class="p">,</span> <span class="n">int_11</span><span class="p">,</span> <span class="n">int_22</span><span class="p">)</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span>
                <span class="n">text</span><span class="p">,</span> <span class="n">calculate_monosymmetry_integrals</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">int_x</span><span class="p">,</span> <span class="n">int_y</span><span class="p">,</span> <span class="n">int_11</span><span class="p">,</span> <span class="n">int_22</span><span class="p">)</span> <span class="o">=</span> <span class="n">calculate_monosymmetry_integrals</span><span class="p">()</span>

        <span class="c1"># calculate the monosymmetry constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_x_plus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">int_x</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y_se</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_x_minus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">int_x</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y_se</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_y_plus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">int_y</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_se</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_y_minus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">int_y</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_se</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_11_plus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">int_11</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">i11_c</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y22_se</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_11_minus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">int_11</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">i11_c</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y22_se</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_22_plus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">int_22</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">i22_c</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x11_se</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_22_minus</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">int_22</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">i22_c</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x11_se</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.calculate_frame_properties"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.CrossSection.calculate_frame_properties">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_frame_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">solver_type</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates and returns the properties required for a frame analysis. The properties are</span>
<span class="sd">        also stored in the :class:`~sectionproperties.analysis.cross_section.SectionProperties`</span>
<span class="sd">        object contained in the ``section_props`` class variable.</span>

<span class="sd">        :param bool time_info: If set to True, a detailed description of the computation and the</span>
<span class="sd">            time cost is printed to the terminal.</span>
<span class="sd">        :param string solver_type: Solver used for solving systems of linear equations, either</span>
<span class="sd">            using the *&#39;direct&#39;* method or *&#39;cgs&#39;* iterative method</span>

<span class="sd">        :return: Cross-section properties to be used for a frame analysis *(area, ixx, iyy, ixy, j,</span>
<span class="sd">            phi)*</span>
<span class="sd">        :rtype: tuple(float, float, float, float, float, float)</span>

<span class="sd">        The following section properties are calculated:</span>

<span class="sd">        * Cross-sectional area *(area)*</span>
<span class="sd">        * Second moments of area about the centroidal axis *(ixx, iyy, ixy)*</span>
<span class="sd">        * Torsion constant *(j)*</span>
<span class="sd">        * Principal axis angle *(phi)*</span>

<span class="sd">        If materials are specified for the cross-section, the area, second moments of area and</span>
<span class="sd">        torsion constant are elastic moulus weighted.</span>

<span class="sd">        The following example demonstrates the use of this method::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            (area, ixx, iyy, ixy, j, phi) = section.calculate_frame_properties()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">calculate_frame</span><span class="p">():</span>
            <span class="c1"># initialise geometric properties</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_g</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_g</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_g</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># calculate global geometric properties</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">,</span> <span class="n">ixx_g</span><span class="p">,</span>
                 <span class="n">iyy_g</span><span class="p">,</span> <span class="n">ixy_g</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">geometric_properties</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span> <span class="o">+=</span> <span class="n">area</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span> <span class="o">+=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qx</span> <span class="o">+=</span> <span class="n">qx</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qy</span> <span class="o">+=</span> <span class="n">qy</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_g</span> <span class="o">+=</span> <span class="n">ixx_g</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_g</span> <span class="o">+=</span> <span class="n">iyy_g</span> <span class="o">*</span> <span class="n">e</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_g</span> <span class="o">+=</span> <span class="n">ixy_g</span> <span class="o">*</span> <span class="n">e</span>

            <span class="c1"># calculate elastic centroid location</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">calculate_elastic_centroid</span><span class="p">()</span>

            <span class="c1"># calculate second moments of area about the centroidal xy axis</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_g</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_g</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_g</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qy</span> <span class="o">/</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span>
            <span class="p">)</span>

            <span class="c1"># calculate the principal axis angle</span>
            <span class="n">Delta</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

            <span class="n">i11_c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Delta</span>
            <span class="p">)</span>

            <span class="c1"># calculate initial principal axis angle</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">-</span> <span class="n">i11_c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span> <span class="o">*</span> <span class="n">i11_c</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">i11_c</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span>
                <span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

            <span class="c1"># create a new CrossSection with the origin shifted to the centroid for calculation of</span>
            <span class="c1"># the warping properties</span>
            <span class="n">warping_section</span> <span class="o">=</span> <span class="n">CrossSection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">)</span>

            <span class="c1"># shift the coordinates of each element N.B. the mesh class attribute remains unshifted</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">warping_section</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="n">el</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span>
                <span class="n">el</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span>

            <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="n">warping_section</span><span class="o">.</span><span class="n">assemble_torsion</span><span class="p">(</span><span class="n">lg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># if the cgs method is used, perform ILU decomposition</span>
            <span class="k">if</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s1">&#39;cgs&#39;</span><span class="p">:</span>
                <span class="n">k_precond</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">),</span> <span class="n">linalg</span><span class="o">.</span><span class="n">spilu</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span>
                <span class="p">)</span>

            <span class="c1"># solve for warping function</span>
            <span class="k">if</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s1">&#39;cgs&#39;</span><span class="p">:</span>
                <span class="n">omega</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve_cgs</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">k_precond</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">solver_type</span> <span class="o">==</span> <span class="s1">&#39;direct&#39;</span><span class="p">:</span>
                <span class="n">omega</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve_direct</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

            <span class="c1"># calculate the torsion constant</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">-</span> <span class="n">omega</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">omega</span><span class="p">)))</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Calculating frame section properties...&quot;</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">calculate_frame</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">calculate_frame</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.calculate_plastic_properties"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.CrossSection.calculate_plastic_properties">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_plastic_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the plastic properties of the cross-section and stores the, in the</span>
<span class="sd">        :class:`~sectionproperties.analysis.cross_section.SectionProperties` object contained in</span>
<span class="sd">        the ``section_props`` class variable.</span>

<span class="sd">        :param bool time_info: If set to True, a detailed description of the computation and the</span>
<span class="sd">            time cost is printed to the terminal.</span>
<span class="sd">        :param bool verbose: If set to True, the number of iterations required for each plastic</span>
<span class="sd">            axis is printed to the terminal.</span>
<span class="sd">        :param bool debug: If set to True, the geometry is plotted each time a new mesh is</span>
<span class="sd">            generated by the plastic centroid algorithm.</span>

<span class="sd">        The following warping section properties are calculated:</span>

<span class="sd">        * Plastic centroid for bending about the centroidal and principal axes</span>
<span class="sd">        * Plastic section moduli for bending about the centroidal and principal axes</span>
<span class="sd">        * Shape factors for bending about the centroidal and principal axes</span>

<span class="sd">        If materials are specified for the cross-section, the plastic section moduli are displayed</span>
<span class="sd">        as plastic moments (i.e :math:`M_p = f_y S`) and the shape factors are not calculated.</span>

<span class="sd">        Note that the geometric properties must be calculated before the plastic properties are</span>
<span class="sd">        calculated::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_plastic_properties()</span>

<span class="sd">        :raises RuntimeError: If the geometric properties have not been calculated prior to calling</span>
<span class="sd">            this method</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that a geometric analysis has been performed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Cacluate geometric properties before performing a plastic analysis.&quot;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">calc_plastic</span><span class="p">():</span>
            <span class="n">plastic_section</span> <span class="o">=</span> <span class="n">PlasticSection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span>

            <span class="c1"># calculate plastic properties</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">plastic_section</span><span class="o">.</span><span class="n">calculate_plastic_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Plastic section properties calculation failed. Contact &quot;</span>
                <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;robbie.vanleeuwen@gmail.com with your analysis parameters.&quot;</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Calculating plastic properties...&quot;</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">calc_plastic</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">calc_plastic</span><span class="p">()</span></div>

<div class="viewcode-block" id="CrossSection.calculate_stress"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.CrossSection.calculate_stress">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_stress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Vx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Vy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Mxx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Myy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M11</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M22</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                         <span class="n">Mzz</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time_info</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the cross-section stress resulting from design actions and returns a</span>
<span class="sd">        :class:`~sectionproperties.analysis.cross_section.StressPost` object allowing</span>
<span class="sd">        post-processing of the stress results.</span>

<span class="sd">        :param float N: Axial force</span>
<span class="sd">        :param float Vx: Shear force acting in the x-direction</span>
<span class="sd">        :param float Vy: Shear force acting in the y-direction</span>
<span class="sd">        :param float Mxx: Bending moment about the centroidal xx-axis</span>
<span class="sd">        :param float Myy: Bending moment about the centroidal yy-axis</span>
<span class="sd">        :param float M11: Bending moment about the centroidal 11-axis</span>
<span class="sd">        :param float M22: Bending moment about the centroidal 22-axis</span>
<span class="sd">        :param float Mzz: Torsion moment about the centroidal zz-axis</span>
<span class="sd">        :param bool time_info: If set to True, a detailed description of the computation and the</span>
<span class="sd">            time cost is printed to the terminal.</span>
<span class="sd">        :return: Object for post-processing cross-section stresses</span>
<span class="sd">        :rtype: :class:`~sectionproperties.analysis.cross_section.StressPost`</span>

<span class="sd">        Note that a geometric and warping analysis must be performed before a stress analysis is</span>
<span class="sd">        carried out::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(N=1e3, Vy=3e3, Mxx=1e6)</span>

<span class="sd">        :raises RuntimeError: If a geometric and warping analysis have not been performed prior to</span>
<span class="sd">            calling this method</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that a geometric and warping analysis has been performed</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">j</span>
        <span class="p">]:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Perform a geometric and warping analysis before carrying out a stress analysis.&quot;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">calc_stress</span><span class="p">():</span>
            <span class="c1"># create stress post object</span>
            <span class="n">stress_post</span> <span class="o">=</span> <span class="n">StressPost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="c1"># get relevant section properties</span>
            <span class="n">ea</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span>
            <span class="n">cx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span>
            <span class="n">cy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span>
            <span class="n">ixx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span>
            <span class="n">iyy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span>
            <span class="n">ixy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span>
            <span class="n">i11</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">i11_c</span>
            <span class="n">i22</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">i22_c</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">j</span>
            <span class="n">Delta_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">Delta_s</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">nu_eff</span>

            <span class="c1"># loop through all material groups</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">stress_post</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
                <span class="c1"># allocate nodal weights vector for nodal averaging</span>
                <span class="n">nodal_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>

                <span class="c1"># loop through all elements in the material group</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                    <span class="p">(</span>
                        <span class="n">sig_zz_n_el</span><span class="p">,</span> <span class="n">sig_zz_mxx_el</span><span class="p">,</span> <span class="n">sig_zz_myy_el</span><span class="p">,</span> <span class="n">sig_zz_m11_el</span><span class="p">,</span> <span class="n">sig_zz_m22_el</span><span class="p">,</span>
                        <span class="n">sig_zx_mzz_el</span><span class="p">,</span> <span class="n">sig_zy_mzz_el</span><span class="p">,</span> <span class="n">sig_zx_vx_el</span><span class="p">,</span> <span class="n">sig_zy_vx_el</span><span class="p">,</span> <span class="n">sig_zx_vy_el</span><span class="p">,</span>
                        <span class="n">sig_zy_vy_el</span><span class="p">,</span> <span class="n">weights</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">element_stress</span><span class="p">(</span>
                        <span class="n">N</span><span class="p">,</span> <span class="n">Mxx</span><span class="p">,</span> <span class="n">Myy</span><span class="p">,</span> <span class="n">M11</span><span class="p">,</span> <span class="n">M22</span><span class="p">,</span> <span class="n">Mzz</span><span class="p">,</span> <span class="n">Vx</span><span class="p">,</span> <span class="n">Vy</span><span class="p">,</span> <span class="n">ea</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">ixx</span><span class="p">,</span> <span class="n">iyy</span><span class="p">,</span> <span class="n">ixy</span><span class="p">,</span> <span class="n">i11</span><span class="p">,</span> <span class="n">i22</span><span class="p">,</span>
                        <span class="n">phi</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">psi_shear</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi_shear</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">],</span> <span class="n">Delta_s</span>
                    <span class="p">)</span>

                    <span class="c1"># add stresses to global vectors</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_n</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zz_n_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_mxx</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zz_mxx_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_myy</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zz_myy_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m11</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zz_m11_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m22</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zz_m22_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_mzz</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zx_mzz_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_mzz</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zy_mzz_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vx</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zx_vx_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vx</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zy_vx_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vy</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zx_vy_el</span> <span class="o">*</span> <span class="n">weights</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vy</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sig_zy_vy_el</span> <span class="o">*</span> <span class="n">weights</span>

                    <span class="c1"># add nodal weights</span>
                    <span class="n">nodal_weights</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weights</span>

                <span class="c1"># nodal averaging</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodal_weights</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">weight</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_mxx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_myy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m11</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m22</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_mzz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_mzz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">weight</span>

                <span class="c1"># calculate combined stresses</span>
                <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">calculate_combined_stresses</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">stress_post</span>

        <span class="k">if</span> <span class="n">time_info</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--Calculating cross-section stresses...&quot;</span>
            <span class="n">stress_post</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">function_timer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">calc_stress</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stress_post</span> <span class="o">=</span> <span class="n">calc_stress</span><span class="p">()</span>

        <span class="c1"># return the stress_post object</span>
        <span class="k">return</span> <span class="n">stress_post</span></div>

<div class="viewcode-block" id="CrossSection.assemble_torsion"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.CrossSection.assemble_torsion">[docs]</a>    <span class="k">def</span> <span class="nf">assemble_torsion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assembles stiffness matrices to be used for the computation of warping properties and</span>
<span class="sd">        the torsion load vector (f_torsion). Both a regular (k) and Lagrangian multiplier (k_lg)</span>
<span class="sd">        stiffness matrix are returned. The stiffness matrices are assembled using the sparse COO</span>
<span class="sd">        format and returned in the sparse CSC format.</span>

<span class="sd">        :param bool lg: Whether or not to calculate the Lagrangian multiplier stiffness matrix</span>

<span class="sd">        :return: Regular stiffness matrix, Lagrangian multiplier stiffness matrix and torsion load</span>
<span class="sd">            vector *(k, k_lg, f_torsion)*</span>
<span class="sd">        :rtype: tuple(:class:`scipy.sparse.csc_matrix`, :class:`scipy.sparse.csc_matrix`,</span>
<span class="sd">            :class:`numpy.ndarray`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialise variables</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span>  <span class="c1"># size of matrix</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list holding row indices</span>
        <span class="n">col</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list holding column indices</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list holding stiffness matrix entries</span>
        <span class="n">f_torsion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># force vector array</span>

        <span class="c1"># loop through all elements in the mesh</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="c1"># determine number of nodes in the current element</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">)</span>

            <span class="c1"># calculate the element stiffness matrix and torsion load vector</span>
            <span class="p">(</span><span class="n">k_el</span><span class="p">,</span> <span class="n">f_el</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">torsion_properties</span><span class="p">()</span>

            <span class="c1"># assemble the torsion load vector</span>
            <span class="n">f_torsion</span><span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f_el</span>

            <span class="c1"># create row index vector</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

            <span class="c1"># create column index vector</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

            <span class="c1"># flatten element stiffness matrix</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k_el</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="c1"># add to global arrays</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">lg</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">f_torsion</span><span class="p">)</span>

        <span class="c1"># construct Lagrangian multiplier matrix:</span>
        <span class="c1"># column vector of ones</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)))</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)))</span>

        <span class="c1"># row vector of ones</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)))</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)))</span>

        <span class="c1"># zero in bottom right corner</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="n">k_lg</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">csc_matrix</span><span class="p">(</span><span class="n">k_lg</span><span class="p">),</span> <span class="n">f_torsion</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.plot_mesh"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.CrossSection.plot_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">materials</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the finite element mesh. If no axes object is supplied a new figure and axis is</span>
<span class="sd">        created.</span>

<span class="sd">        :param ax: Axes object on which the mesh is plotted</span>
<span class="sd">        :type ax: :class:`matplotlib.axes.Axes`</span>
<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>
<span class="sd">        :param float alpha: Transparency of the mesh outlines: :math:`0 \leq \\alpha \leq 1`</span>
<span class="sd">        :param bool materials: If set to true and material properties have been provided to the</span>
<span class="sd">            :class:`~sectionproperties.analysis.cross_section.CrossSection` object, shades the</span>
<span class="sd">            elements with the specified material colours</span>
<span class="sd">        :param mask: Mask array, of length ``num_nodes``, to mask out triangles</span>
<span class="sd">        :type mask: list[bool]</span>

<span class="sd">        The following example plots the mesh generated for the second example</span>
<span class="sd">        listed under the :class:`~sectionproperties.analysis.cross_section.CrossSection` object</span>
<span class="sd">        definition::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.pre.pre import Material</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geom_steel = sections.RectangularSection(d=50, b=50)</span>
<span class="sd">            geom_timber = sections.RectangularSection(d=50, b=50, shift=[50, 0])</span>
<span class="sd">            geometry = sections.MergedSection([geom_steel, geom_timber])</span>
<span class="sd">            geometry.clean_geometry()</span>

<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[5, 10])</span>

<span class="sd">            steel = Material(</span>
<span class="sd">                name=&#39;Steel&#39;, elastic_modulus=200e3, poissons_ratio=0.3, yield_strength=250,</span>
<span class="sd">                color=&#39;grey&#39;</span>
<span class="sd">            )</span>
<span class="sd">            timber = Material(</span>
<span class="sd">                name=&#39;Timber&#39;, elastic_modulus=8e3, poissons_ratio=0.35, yield_strength=20,</span>
<span class="sd">                color=&#39;burlywood&#39;</span>
<span class="sd">            )</span>

<span class="sd">            section = CrossSection(geometry, mesh, [steel, timber])</span>
<span class="sd">            section.plot_mesh(materials=True, alpha=0.5)</span>

<span class="sd">        ..  figure:: ../images/composite_mesh.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Finite element mesh generated by the above example.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if no axes object is supplied, create and setup the plot</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax_supplied</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">post</span><span class="o">.</span><span class="n">setup_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax_supplied</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># plot the mesh</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_elements</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span>
        <span class="p">)</span>

        <span class="c1"># if the material colours are to be displayed</span>
        <span class="k">if</span> <span class="n">materials</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color_array</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">legend_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># create an array of finite element colours</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                <span class="n">color_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>

            <span class="c1"># create a list of unique material legend entries</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">material</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">):</span>
                <span class="c1"># if the material has not be entered yet</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">material</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># add the material colour and name to the legend list</span>
                    <span class="n">legend_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">material</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">material</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="n">cmap</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">color_array</span><span class="p">)</span>  <span class="c1"># custom colormap</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">color_array</span><span class="p">))</span>  <span class="c1"># indicies of elements</span>

            <span class="c1"># plot the mesh colours</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tripcolor</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_elements</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span>
            <span class="p">)</span>

            <span class="c1"># display the legend</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center left&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">handles</span><span class="o">=</span><span class="n">legend_list</span><span class="p">)</span>

        <span class="c1"># if no axes object is supplied, finish the plot</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax_supplied</span><span class="p">:</span>
            <span class="n">post</span><span class="o">.</span><span class="n">finish_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Finite Element Mesh&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.plot_centroids"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.plot_centroids">[docs]</a>    <span class="k">def</span> <span class="nf">plot_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the elastic centroid, the shear centre, the plastic centroids and the principal</span>
<span class="sd">        axis, if they have been calculated, on top of the finite element mesh.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example analyses a 200 PFC section and displays a plot of</span>
<span class="sd">        the centroids::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.PfcSection(d=200, b=75, t_f=12, t_w=6, r=12, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            section.calculate_plastic_properties()</span>

<span class="sd">            section.plot_centroids()</span>

<span class="sd">        ..  figure:: ../images/pfc_centroids.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Plot of the centroids generated by the above example.</span>

<span class="sd">        The following example analyses a 150x90x12 UA section and displays a plot of the</span>
<span class="sd">        centroids::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            section.calculate_plastic_properties()</span>

<span class="sd">            section.plot_centroids()</span>

<span class="sd">        ..  figure:: ../images/angle_centroids.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Plot of the centroids generated by the above example.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create plot and setup the plot</span>
        <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">post</span><span class="o">.</span><span class="n">setup_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span>

        <span class="c1"># plot the finite element mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_mesh</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># if the elastic centroid has been calculated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Elastic centroid&#39;</span>
            <span class="p">)</span>

        <span class="c1"># if the shear centre has been calculated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_se</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">x_s</span><span class="p">,</span> <span class="n">y_s</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sc</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_s</span><span class="p">,</span> <span class="n">y_s</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Shear centre&#39;</span><span class="p">)</span>

        <span class="c1"># if the global plastic centroid has been calculated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_pc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">x_pc</span><span class="p">,</span> <span class="n">y_pc</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pc</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_pc</span><span class="p">,</span> <span class="n">y_pc</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Global plastic centroid&#39;</span><span class="p">)</span>

        <span class="c1"># if the principal plastic centroid has been calculated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x11_pc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">x11_pc</span><span class="p">,</span> <span class="n">y22_pc</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pc_p</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">x11_pc</span><span class="p">,</span> <span class="n">y22_pc</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Principal plastic centroid&#39;</span>
            <span class="p">)</span>

        <span class="c1"># if the principal axis has been calculated</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">post</span><span class="o">.</span><span class="n">draw_principal_axis</span><span class="p">(</span>
                <span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span>
            <span class="p">)</span>

        <span class="c1"># display the legend</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center left&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>

        <span class="c1"># finish the plot</span>
        <span class="n">post</span><span class="o">.</span><span class="n">finish_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Centroids&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.display_mesh_info"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.CrossSection.display_mesh_info">[docs]</a>    <span class="k">def</span> <span class="nf">display_mesh_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints mesh statistics (number of nodes, elements and regions) to the command window.</span>

<span class="sd">        The following example displays the mesh statistics for a Tee section merged from two</span>
<span class="sd">        rectangles::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            rec1 = sections.RectangularSection(d=100, b=25, shift=[-12.5, 0])</span>
<span class="sd">            rec2 = sections.RectangularSection(d=25, b=100, shift=[-50, 100])</span>
<span class="sd">            geometry = sections.MergedSection([rec1, rec2])</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[5, 2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.display_mesh_info()</span>

<span class="sd">            &gt;&gt;&gt;Mesh Statistics:</span>
<span class="sd">            &gt;&gt;&gt;--4920 nodes</span>
<span class="sd">            &gt;&gt;&gt;--2365 elements</span>
<span class="sd">            &gt;&gt;&gt;--2 regions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh Statistics:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--</span><span class="si">{0}</span><span class="s2"> nodes&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--</span><span class="si">{0}</span><span class="s2"> elements&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)))</span>

        <span class="n">regions</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_attributes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;--</span><span class="si">{0}</span><span class="s2"> region&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">regions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;s</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.display_results"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.display_results">[docs]</a>    <span class="k">def</span> <span class="nf">display_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;8.6e&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints the results that have been calculated to the terminal.</span>

<span class="sd">        :param string fmt: Number formatting string</span>

<span class="sd">        The following example displays the geometric section properties for a 100D x 50W rectangle</span>
<span class="sd">        with three digits after the decimal point::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.RectangularSection(d=100, b=50)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[5])</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>

<span class="sd">            section.display_results(fmt=&#39;.3f&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">post</span><span class="o">.</span><span class="n">print_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_area"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_area">[docs]</a>    <span class="k">def</span> <span class="nf">get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Cross-section area</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            area = section.get_area()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">area</span></div>

<div class="viewcode-block" id="CrossSection.get_perimeter"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_perimeter">[docs]</a>    <span class="k">def</span> <span class="nf">get_perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Cross-section perimeter</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            perimeter = section.get_perimeter()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">perimeter</span></div>

<div class="viewcode-block" id="CrossSection.get_ea"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_ea">[docs]</a>    <span class="k">def</span> <span class="nf">get_ea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Modulus weighted area (axial rigidity)</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            ea = section.get_ea()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ea</span></div>

<div class="viewcode-block" id="CrossSection.get_q"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_q">[docs]</a>    <span class="k">def</span> <span class="nf">get_q</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: First moments of area about the global axis *(qx, qy)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            (qx, qy) = section.get_q()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">qy</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_ig"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_ig">[docs]</a>    <span class="k">def</span> <span class="nf">get_ig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Second moments of area about the global axis *(ixx_g, iyy_g, ixy_g)*</span>
<span class="sd">        :rtype: tuple(float, float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            (ixx_g, iyy_g, ixy_g) = section.get_ig()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_g</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_c"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_c">[docs]</a>    <span class="k">def</span> <span class="nf">get_c</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Elastic centroid *(cx, cy)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            (cx, cy) = section.get_c()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_ic"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_ic">[docs]</a>    <span class="k">def</span> <span class="nf">get_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Second moments of area centroidal axis *(ixx_c, iyy_c, ixy_c)*</span>
<span class="sd">        :rtype: tuple(float, float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            (ixx_c, iyy_c, ixy_c) = section.get_ic()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixx_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ixy_c</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_z"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_z">[docs]</a>    <span class="k">def</span> <span class="nf">get_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Elastic section moduli about the centroidal axis with respect to the top and</span>
<span class="sd">            bottom fibres *(zxx_plus, zxx_minus, zyy_plus, zyy_minus)*</span>
<span class="sd">        :rtype: tuple(float, float, float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            (zxx_plus, zxx_minus, zyy_plus, zyy_minus) = section.get_z()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">zxx_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">zxx_minus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">zyy_plus</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">zyy_minus</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_rc"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_rc">[docs]</a>    <span class="k">def</span> <span class="nf">get_rc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Radii of gyration about the centroidal axis *(rx, ry)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            (rx, ry) = section.get_rc()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">rx_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">ry_c</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_ip"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_ip">[docs]</a>    <span class="k">def</span> <span class="nf">get_ip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Second moments of area about the principal axis *(i11_c, i22_c)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            (i11_c, i22_c) = section.get_ip()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">i11_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">i22_c</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_phi"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_phi">[docs]</a>    <span class="k">def</span> <span class="nf">get_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Principal bending axis angle</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            phi = section.get_phi()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span></div>

<div class="viewcode-block" id="CrossSection.get_zp"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_zp">[docs]</a>    <span class="k">def</span> <span class="nf">get_zp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Elastic section moduli about the principal axis with respect to the top and bottom</span>
<span class="sd">            fibres *(z11_plus, z11_minus, z22_plus, z22_minus)*</span>
<span class="sd">        :rtype: tuple(float, float, float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            (z11_plus, z11_minus, z22_plus, z22_minus) = section.get_zp()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">z11_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">z11_minus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">z22_plus</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">z22_minus</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_rp"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_rp">[docs]</a>    <span class="k">def</span> <span class="nf">get_rp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Radii of gyration about the principal axis *(r11, r22)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            (r11, r22) = section.get_rp()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">r11_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">r22_c</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_j"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_j">[docs]</a>    <span class="k">def</span> <span class="nf">get_j</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: St. Venant torsion constant</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            j = section.get_j()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">j</span></div>

<div class="viewcode-block" id="CrossSection.get_sc"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_sc">[docs]</a>    <span class="k">def</span> <span class="nf">get_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Centroidal axis shear centre (elasticity approach) *(x_se, y_se)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            (x_se, y_se) = section.get_sc()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_se</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># add centroid location to move section back to original location</span>
            <span class="n">x_se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_se</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span>
            <span class="n">y_se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y_se</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">x_se</span><span class="p">,</span> <span class="n">y_se</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_sc_p"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_sc_p">[docs]</a>    <span class="k">def</span> <span class="nf">get_sc_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Principal axis shear centre (elasticity approach) *(x11_se, y22_se)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            (x11_se, y22_se) = section.get_sc_p()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x11_se</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x11_se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x11_se</span>
            <span class="n">y22_se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y22_se</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">x11_se</span><span class="p">,</span> <span class="n">y22_se</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_sc_t"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_sc_t">[docs]</a>    <span class="k">def</span> <span class="nf">get_sc_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Centroidal axis shear centre (Trefftz&#39;s approach) *(x_st, y_st)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            (x_st, y_st) = section.get_sc_t()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_st</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># add centroid location to move section back to original location</span>
            <span class="n">x_st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_st</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span>
            <span class="n">y_st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y_st</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">x_st</span><span class="p">,</span> <span class="n">y_st</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_gamma"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_gamma">[docs]</a>    <span class="k">def</span> <span class="nf">get_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Warping constant</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            gamma = section.get_gamma()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">gamma</span></div>

<div class="viewcode-block" id="CrossSection.get_As"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_As">[docs]</a>    <span class="k">def</span> <span class="nf">get_As</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Shear area for loading about the centroidal axis *(A_sx, A_sy)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            (A_sx, A_sy) = section.get_As()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">A_sx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">A_sy</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_As_p"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_As_p">[docs]</a>    <span class="k">def</span> <span class="nf">get_As_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Shear area for loading about the principal bending axis *(A_s11, A_s22)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            (A_s11, A_s22) = section.get_As_p()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">A_s11</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">A_s22</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_beta"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_beta">[docs]</a>    <span class="k">def</span> <span class="nf">get_beta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Monosymmetry constant for bending about both global axes *(beta_x_plus,</span>
<span class="sd">            beta_x_minus, beta_y_plus, beta_y_minus)*. The *plus* value relates to the top flange</span>
<span class="sd">            in compression and the *minus* value relates to the bottom flange in compression.</span>
<span class="sd">        :rtype: tuple(float, float, float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            (beta_x_plus, beta_x_minus, beta_y_plus, beta_y_minus) = section.get_beta()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_x_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_x_minus</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_y_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_y_minus</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_beta_p"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_beta_p">[docs]</a>    <span class="k">def</span> <span class="nf">get_beta_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Monosymmetry constant for bending about both principal axes *(beta_11_plus,</span>
<span class="sd">            beta_11_minus, beta_22_plus, beta_22_minus)*. The *plus* value relates to the top</span>
<span class="sd">            flange in compression and the *minus* value relates to the bottom flange in</span>
<span class="sd">            compression.</span>
<span class="sd">        :rtype: tuple(float, float, float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            (beta_11_plus, beta_11_minus, beta_22_plus, beta_22_minus) = section.get_beta_p()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_11_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_11_minus</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_22_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">beta_22_minus</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_pc"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_pc">[docs]</a>    <span class="k">def</span> <span class="nf">get_pc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Centroidal axis plastic centroid *(x_pc, y_pc)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_plastic_properties()</span>
<span class="sd">            (x_pc, y_pc) = section.get_pc()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_pc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># add centroid location to move section back to original location</span>
            <span class="n">x_pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_pc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span>
            <span class="n">y_pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y_pc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">x_pc</span><span class="p">,</span> <span class="n">y_pc</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_pc_p"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_pc_p">[docs]</a>    <span class="k">def</span> <span class="nf">get_pc_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Principal bending axis plastic centroid *(x11_pc, y22_pc)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_plastic_properties()</span>
<span class="sd">            (x11_pc, y22_pc) = section.get_pc_p()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x11_pc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># determine the position of the plastic centroid in the global axis</span>
            <span class="p">(</span><span class="n">x_pc</span><span class="p">,</span> <span class="n">y_pc</span><span class="p">)</span> <span class="o">=</span> <span class="n">fea</span><span class="o">.</span><span class="n">global_coordinate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x11_pc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y22_pc</span>
            <span class="p">)</span>

            <span class="c1"># add centroid location to move section back to original location</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x_pc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cx</span><span class="p">,</span> <span class="n">y_pc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">cy</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_s"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_s">[docs]</a>    <span class="k">def</span> <span class="nf">get_s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Plastic section moduli about the centroidal axis *(sxx, syy)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        If material properties have been specified, returns the plastic moment :math:`M_p = f_y S`.</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_plastic_properties()</span>
<span class="sd">            (sxx, syy) = section.get_s()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sxx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">syy</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_sp"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_sp">[docs]</a>    <span class="k">def</span> <span class="nf">get_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Plastic section moduli about the principal bending axis *(s11, s22)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>

<span class="sd">        If material properties have been specified, returns the plastic moment</span>
<span class="sd">        :math:`M_p = f_y S`.</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_plastic_properties()</span>
<span class="sd">            (s11, s22) = section.get_sp()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">s11</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">s22</span><span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_sf"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_sf">[docs]</a>    <span class="k">def</span> <span class="nf">get_sf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Centroidal axis shape factors with respect to the top and bottom fibres</span>
<span class="sd">            *(sf_xx_plus, sf_xx_minus, sf_yy_plus, sf_yy_minus)*</span>
<span class="sd">        :rtype: tuple(float, float, float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_plastic_properties()</span>
<span class="sd">            (sf_xx_plus, sf_xx_minus, sf_yy_plus, sf_yy_minus) = section.get_sf()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_xx_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_xx_minus</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_yy_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_yy_minus</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CrossSection.get_sf_p"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.CrossSection.get_sf_p">[docs]</a>    <span class="k">def</span> <span class="nf">get_sf_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Principal bending axis shape factors with respect to the top and bottom fibres</span>
<span class="sd">            *(sf_11_plus, sf_11_minus, sf_22_plus, sf_22_minus)*</span>
<span class="sd">        :rtype: tuple(float, float, float, float)</span>

<span class="sd">        ::</span>

<span class="sd">            section = CrossSection(geometry, mesh)</span>
<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_plastic_properties()</span>
<span class="sd">            (sf_11_plus, sf_11_minus, sf_22_plus, sf_22_minus) = section.get_sf_p()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_11_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_11_minus</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_22_plus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_22_minus</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="PlasticSection"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection">[docs]</a><span class="k">class</span> <span class="nc">PlasticSection</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for the plastic analysis of cross-sections.</span>

<span class="sd">    Stores the finite element geometry and material information and provides methods to compute the</span>
<span class="sd">    plastic section properties.</span>

<span class="sd">    :param geometry: Cross-section geometry object</span>
<span class="sd">    :type geometry: :class:`~sectionproperties.pre.sections.Geometry`</span>
<span class="sd">    :param materials: A list of material properties corresponding to various regions in the</span>
<span class="sd">        geometry and mesh.</span>
<span class="sd">    :type materials: list[:class:`~sectionproperties.pre.pre.Material`]</span>
<span class="sd">    :param bool debug: If set to True, the geometry is plotted each time a new mesh is generated by</span>
<span class="sd">        the plastic centroid algorithm.</span>

<span class="sd">    :cvar geometry: Deep copy of the cross-section geometry object provided to the constructor</span>
<span class="sd">    :vartype geometry: :class:`~sectionproperties.pre.sections.Geometry`</span>
<span class="sd">    :cvar materials: A list of material properties corresponding to various regions in the geometry</span>
<span class="sd">        and mesh.</span>
<span class="sd">    :vartype materials: list[:class:`~sectionproperties.pre.pre.Material`]</span>
<span class="sd">    :cvar bool debug: If set to True, the geometry is plotted each time a new mesh is generated by</span>
<span class="sd">        the plastic centroid algorithm.</span>
<span class="sd">    :cvar mesh: Mesh object returned by meshpy</span>
<span class="sd">    :vartype mesh: :class:`meshpy.triangle.MeshInfo`</span>
<span class="sd">    :cvar mesh_nodes: Array of node coordinates from the mesh</span>
<span class="sd">    :vartype mesh_nodes: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar mesh_elements: Array of connectivities from the mesh</span>
<span class="sd">    :vartype mesh_elements: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar elements: List of finite element objects describing the cross-section mesh</span>
<span class="sd">    :vartype elements: list[:class:`~sectionproperties.analysis.fea.Tri6`]</span>
<span class="sd">    :cvar float f_top: Current force in the top region</span>
<span class="sd">    :cvar c_top: Centroid of the force in the top region *(c_top_x, c_top_y)*</span>
<span class="sd">    :type c_top: list[float, float]</span>
<span class="sd">    :cvar c_bot: Centroid of the force in the bottom region *(c_bot_x, c_bot_y)*</span>
<span class="sd">    :type c_bot: list[float, float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">materials</span><span class="p">,</span> <span class="n">debug</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the PlasticSection class.&quot;&quot;&quot;</span>

        <span class="c1"># make a deepcopy of the geometry &amp; materials so that we can modify it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">materials</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># create dummy control point at the start of the list</span>
            <span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">calculate_extents</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">control_points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">x_min</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y_min</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># create matching dummy material</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pre</span><span class="o">.</span><span class="n">Material</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># create simple mesh of the geometry</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_plastic_mesh</span><span class="p">()</span>

        <span class="c1"># get the elements of the mesh</span>
        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elements</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># calculate centroid of the mesh</span>
        <span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_centroid</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>

        <span class="c1"># shift geometry such that the origin is at the centroid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">cx</span><span class="p">,</span> <span class="o">-</span><span class="n">cy</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span>

        <span class="c1"># remesh the geometry and store the mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_plastic_mesh</span><span class="p">()</span>

        <span class="c1"># store the nodes, elements and list of elements in the mesh</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elements</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

<div class="viewcode-block" id="PlasticSection.get_elements"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.get_elements">[docs]</a>    <span class="k">def</span> <span class="nf">get_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts finite elements from the provided mesh and returns Tri6 finite elements with</span>
<span class="sd">        their associated material properties.</span>

<span class="sd">        :param mesh: Mesh object returned by meshpy</span>
<span class="sd">        :type mesh: :class:`meshpy.triangle.MeshInfo`</span>
<span class="sd">        :return: A tuple containing an array of the nodes locations, element indicies and a list of</span>
<span class="sd">            the finite elements.</span>
<span class="sd">        :rtype: tuple(:class:`numpy.ndarray`, :class:`numpy.ndarray`,</span>
<span class="sd">            list[:class:`~sectionproperties.analysis.fea.Tri6`])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># extract mesh data</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">element_attributes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

        <span class="c1"># swap mid-node order to retain node ordering consistency</span>
        <span class="n">elements</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

        <span class="c1"># initialise list of Tri6 elements</span>
        <span class="n">element_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># build the element list one element at a time</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x3</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y3</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x4</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y4</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x5</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">4</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y5</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">4</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x6</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">5</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y6</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node_ids</span><span class="p">[</span><span class="mi">5</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># create a list containing the vertex and mid-node coordinates</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="n">x5</span><span class="p">,</span> <span class="n">x6</span><span class="p">],</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">y4</span><span class="p">,</span> <span class="n">y5</span><span class="p">,</span> <span class="n">y6</span><span class="p">]])</span>

            <span class="c1"># if materials are specified, get the material</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># get attribute index of current element</span>
                <span class="n">att_el</span> <span class="o">=</span> <span class="n">attributes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="c1"># if the current element is assigned the default attribute</span>
                <span class="k">if</span> <span class="n">att_el</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># determine point within current element (centroid)</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">y1</span> <span class="o">+</span> <span class="n">y2</span> <span class="o">+</span> <span class="n">y3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">]</span>

                    <span class="c1"># search within original elements - find coinciding element</span>
                    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
                        <span class="c1"># if the point lies within the current element</span>
                        <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">point_within_element</span><span class="p">(</span><span class="n">pt</span><span class="p">):</span>
                            <span class="n">material</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">material</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># fetch the material</span>
                    <span class="n">material</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">att_el</span><span class="p">]</span>
            <span class="c1"># if there are no materials specified, use a default material</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">material</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">Material</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># add tri6 elements to the element list</span>
            <span class="n">element_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fea</span><span class="o">.</span><span class="n">Tri6</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">,</span> <span class="n">material</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">element_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlasticSection.calculate_centroid"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.calculate_centroid">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the elastic centroid from a list of finite elements.</span>

<span class="sd">        :param elements: A list of Tri6 finite elements.</span>
<span class="sd">        :type elements: list[:class:`~sectionproperties.analysis.fea.Tri6`]</span>
<span class="sd">        :return: A tuple containing the x and y location of the elastic centroid.</span>
<span class="sd">        :rtype: tuple(float, float)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ea</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">qx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">qy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># loop through all the elements</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">qx_el</span><span class="p">,</span> <span class="n">qy_el</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">geometric_properties</span><span class="p">()</span>
            <span class="n">ea</span> <span class="o">+=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">e</span>
            <span class="n">qx</span> <span class="o">+=</span> <span class="n">qx_el</span> <span class="o">*</span> <span class="n">e</span>
            <span class="n">qy</span> <span class="o">+=</span> <span class="n">qy_el</span> <span class="o">*</span> <span class="n">e</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">qy</span> <span class="o">/</span> <span class="n">ea</span><span class="p">,</span> <span class="n">qx</span> <span class="o">/</span> <span class="n">ea</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlasticSection.calculate_plastic_properties"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.calculate_plastic_properties">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_plastic_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cross_section</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the location of the plastic centroid with respect to the centroidal and</span>
<span class="sd">        principal bending axes, the plastic section moduli and shape factors and stores the results</span>
<span class="sd">        to the supplied :class:`~sectionproperties.analysis.cross_section.CrossSection` object.</span>

<span class="sd">        :param cross_section: Cross section object that uses the same geometry and materials</span>
<span class="sd">            specified in the class constructor</span>
<span class="sd">        :type cross_section: :class:`~sectionproperties.analysis.cross_section.CrossSection`</span>
<span class="sd">        :param bool verbose: If set to True, the number of iterations required for each plastic</span>
<span class="sd">            axis is printed to the terminal.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1) Calculate plastic properties for centroidal axis</span>
        <span class="c1"># calculate distances to the extreme fibres</span>
        <span class="n">fibres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_extreme_fibres</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># 1a) Calculate x-axis plastic centroid</span>
        <span class="p">(</span><span class="n">y_pc</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c_top</span><span class="p">,</span> <span class="n">c_bot</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pc_algorithm</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">fibres</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_convergence</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;x-axis&#39;</span><span class="p">)</span>
        <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y_pc</span> <span class="o">=</span> <span class="n">y_pc</span>
        <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sxx</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">c_top</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_bot</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_verbose</span><span class="p">(</span><span class="n">y_pc</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="s1">&#39;x-axis&#39;</span><span class="p">)</span>

        <span class="c1"># 1b) Calculate y-axis plastic centroid</span>
        <span class="p">(</span><span class="n">x_pc</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c_top</span><span class="p">,</span> <span class="n">c_bot</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pc_algorithm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">fibres</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_convergence</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;y-axis&#39;</span><span class="p">)</span>
        <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x_pc</span> <span class="o">=</span> <span class="n">x_pc</span>
        <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">syy</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">c_top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_bot</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_verbose</span><span class="p">(</span><span class="n">x_pc</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="s1">&#39;y-axis&#39;</span><span class="p">)</span>

        <span class="c1"># 2) Calculate plastic properties for principal axis</span>
        <span class="c1"># convert principal axis angle to radians</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>

        <span class="c1"># unit vectors in the axis directions</span>
        <span class="n">ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)])</span>
        <span class="n">uy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)])</span>

        <span class="c1"># calculate distances to the extreme fibres in the principal axis</span>
        <span class="n">fibres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_extreme_fibres</span><span class="p">(</span><span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>

        <span class="c1"># 2a) Calculate 11-axis plastic centroid</span>
        <span class="p">(</span><span class="n">y22_pc</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c_top</span><span class="p">,</span> <span class="n">c_bot</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pc_algorithm</span><span class="p">(</span><span class="n">ux</span><span class="p">,</span> <span class="n">fibres</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># calculate the centroids in the principal coordinate system</span>
        <span class="n">c_top_p</span> <span class="o">=</span> <span class="n">fea</span><span class="o">.</span><span class="n">principal_coordinate</span><span class="p">(</span><span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">c_top</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_top</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c_bot_p</span> <span class="o">=</span> <span class="n">fea</span><span class="o">.</span><span class="n">principal_coordinate</span><span class="p">(</span><span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">c_bot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_bot</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_convergence</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;11-axis&#39;</span><span class="p">)</span>
        <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">y22_pc</span> <span class="o">=</span> <span class="n">y22_pc</span>
        <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">s11</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">c_top_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_bot_p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_verbose</span><span class="p">(</span><span class="n">y22_pc</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="s1">&#39;11-axis&#39;</span><span class="p">)</span>

        <span class="c1"># 2b) Calculate 22-axis plastic centroid</span>
        <span class="p">(</span><span class="n">x11_pc</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c_top</span><span class="p">,</span> <span class="n">c_bot</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pc_algorithm</span><span class="p">(</span><span class="n">uy</span><span class="p">,</span> <span class="n">fibres</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># calculate the centroids in the principal coordinate system</span>
        <span class="n">c_top_p</span> <span class="o">=</span> <span class="n">fea</span><span class="o">.</span><span class="n">principal_coordinate</span><span class="p">(</span><span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">c_top</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_top</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c_bot_p</span> <span class="o">=</span> <span class="n">fea</span><span class="o">.</span><span class="n">principal_coordinate</span><span class="p">(</span><span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">c_bot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_bot</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_convergence</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;22-axis&#39;</span><span class="p">)</span>
        <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">x11_pc</span> <span class="o">=</span> <span class="n">x11_pc</span>
        <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">s22</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">c_top_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_bot_p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_verbose</span><span class="p">(</span><span class="n">x11_pc</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="s1">&#39;22-axis&#39;</span><span class="p">)</span>

        <span class="c1"># if there are no materials specified, calculate shape factors</span>
        <span class="k">if</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">materials</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_xx_plus</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sxx</span> <span class="o">/</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">zxx_plus</span>
            <span class="p">)</span>
            <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_xx_minus</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sxx</span> <span class="o">/</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">zxx_minus</span>
            <span class="p">)</span>
            <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_yy_plus</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">syy</span> <span class="o">/</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">zyy_plus</span>
            <span class="p">)</span>
            <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_yy_minus</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">syy</span> <span class="o">/</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">zyy_minus</span>
            <span class="p">)</span>

            <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_11_plus</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">s11</span> <span class="o">/</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">z11_plus</span>
            <span class="p">)</span>
            <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_11_minus</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">s11</span> <span class="o">/</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">z11_minus</span>
            <span class="p">)</span>
            <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_22_plus</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">s22</span> <span class="o">/</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">z22_plus</span>
            <span class="p">)</span>
            <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">sf_22_minus</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">s22</span> <span class="o">/</span> <span class="n">cross_section</span><span class="o">.</span><span class="n">section_props</span><span class="o">.</span><span class="n">z22_minus</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="PlasticSection.check_convergence"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.check_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">check_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_result</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that the function solver converged and if not, raises a helpful error.</span>

<span class="sd">        :param root_result: Result object from the root finder</span>
<span class="sd">        :type root_result: :class:`scipy.optimize.RootResults`</span>
<span class="sd">        :param string axis: Axis being considered by the function sovler</span>
<span class="sd">        :raises RuntimeError: If the function solver did not converge</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">root_result</span><span class="o">.</span><span class="n">converged</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Plastic centroid calculation about the </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot; failed. Contact robbie.vanleeuwen@gmail.com with your&quot;</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot; analysis parameters. Termination flag: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">root_result</span><span class="o">.</span><span class="n">flag</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlasticSection.print_verbose"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.print_verbose">[docs]</a>    <span class="k">def</span> <span class="nf">print_verbose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">root_result</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints information related to the function solver convergence to the terminal.</span>

<span class="sd">        :param float d: Location of the plastic centroid axis</span>
<span class="sd">        :param root_result: Result object from the root finder</span>
<span class="sd">        :type root_result: :class:`scipy.optimize.RootResults`</span>
<span class="sd">        :param string axis: Axis being considered by the function sovler</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;---</span><span class="si">{0}</span><span class="s2"> plastic centroid calculation converged at &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{0:.5e}</span><span class="s2"> in </span><span class="si">{1}</span><span class="s2"> iterations.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">root_result</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlasticSection.calculate_extreme_fibres"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.calculate_extreme_fibres">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_extreme_fibres</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the locations of the extreme fibres along and perpendicular to the axis</span>
<span class="sd">        specified by &#39;angle&#39; using the elements stored in `self.elements`.</span>

<span class="sd">        :param float angle: Angle (in radians) along which to calculate the extreme fibre locations</span>
<span class="sd">        :return: The location of the extreme fibres parallel (u) and perpendicular (v) to the axis</span>
<span class="sd">            *(u_min, u_max, v_min, v_max)*</span>
<span class="sd">        :rtype: tuple(float, float, float, float)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># loop through all nodes in the mesh</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">):</span>
            <span class="c1"># determine the coordinate of the point wrt the axis</span>
            <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">fea</span><span class="o">.</span><span class="n">principal_coordinate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># initialise min, max variables</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">u_min</span> <span class="o">=</span> <span class="n">u</span>
                <span class="n">u_max</span> <span class="o">=</span> <span class="n">u</span>
                <span class="n">v_min</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">v_max</span> <span class="o">=</span> <span class="n">v</span>

            <span class="c1"># update the mins and maxs where necessary</span>
            <span class="n">u_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">u_min</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">u_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">u_max</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">v_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">v_min</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">v_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">v_max</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">u_min</span><span class="p">,</span> <span class="n">u_max</span><span class="p">,</span> <span class="n">v_min</span><span class="p">,</span> <span class="n">v_max</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlasticSection.evaluate_force_eq"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.evaluate_force_eq">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_force_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_p</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a distance *d* from the centroid to an axis (defined by unit vector *u*), creates</span>
<span class="sd">        a mesh including the new and axis and calculates the force equilibrium. The resultant</span>
<span class="sd">        force, as a ratio of the total force, is returned.</span>

<span class="sd">        :param float d: Distance from the centroid to current axis</span>
<span class="sd">        :param u: Unit vector defining the direction of the axis</span>
<span class="sd">        :type u: :class:`numpy.ndarray`</span>
<span class="sd">        :param u_p: Unit vector perpendicular to the direction of the axis</span>
<span class="sd">        :type u_p: :class:`numpy.ndarray`</span>
<span class="sd">        :param bool verbose: If set to True, the number of iterations required for each plastic</span>
<span class="sd">            axis is printed to the terminal.</span>
<span class="sd">        :return: The force equilibrium norm</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span> <span class="o">*</span> <span class="n">u_p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span> <span class="o">*</span> <span class="n">u_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># create a mesh with the axis included</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_plastic_mesh</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
        <span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">element_list</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elements</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_mesh</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">element_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">)</span>

        <span class="c1"># calculate force equilibrium</span>
        <span class="p">(</span><span class="n">f_top</span><span class="p">,</span> <span class="n">f_bot</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_plastic_force</span><span class="p">(</span><span class="n">element_list</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># calculate the force norm</span>
        <span class="n">f_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_top</span> <span class="o">-</span> <span class="n">f_bot</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">f_top</span> <span class="o">+</span> <span class="n">f_bot</span><span class="p">)</span>

        <span class="c1"># print verbose results</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;d = </span><span class="si">{0}</span><span class="s2">; f_norm = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">f_norm</span><span class="p">))</span>

        <span class="c1"># return the force norm</span>
        <span class="k">return</span> <span class="n">f_norm</span></div>

<div class="viewcode-block" id="PlasticSection.pc_algorithm"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.pc_algorithm">[docs]</a>    <span class="k">def</span> <span class="nf">pc_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dlim</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An algorithm used for solving for the location of the plastic centroid. The algorithm</span>
<span class="sd">        searches for the location of the axis, defined by unit vector *u* and within the section</span>
<span class="sd">        depth, that satisfies force equilibrium.</span>

<span class="sd">        :param u: Unit vector defining the direction of the axis</span>
<span class="sd">        :type u: :class:`numpy.ndarray`</span>
<span class="sd">        :param dlim: List [dmax, dmin] containing the distances from the centroid to the extreme</span>
<span class="sd">            fibres perpendicular to the axis</span>
<span class="sd">        :type dlim: list[float, float]</span>
<span class="sd">        :param int axis: The current axis direction: 1 (e.g. x or 11) or 2 (e.g. y or 22)</span>
<span class="sd">        :param bool verbose: If set to True, the number of iterations required for each plastic</span>
<span class="sd">            axis is printed to the terminal.</span>
<span class="sd">        :return: The distance to the plastic centroid axis *d*, the result object *r*, the force in</span>
<span class="sd">            the top of the section *f_top* and the location of the centroids of the top and bottom</span>
<span class="sd">            areas *c_top* and *c_bottom*</span>
<span class="sd">        :rtype: tuple(float, :class:`scipy.optimize.RootResults`, float, list[float, float],</span>
<span class="sd">            list[float, float])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate vector perpendicular to u</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">u_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">dlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">dlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_force_eq</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_p</span><span class="p">,</span> <span class="n">verbose</span><span class="p">),</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_bot</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlasticSection.calculate_plastic_force"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.calculate_plastic_force">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_plastic_force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sums the forces above and below the axis defined by unit vector *u* and point *p*. Also</span>
<span class="sd">        returns the force centroid of the forces above and below the axis.</span>

<span class="sd">        :param elements: A list of Tri6 finite elements.</span>
<span class="sd">        :type elements: list[:class:`~sectionproperties.analysis.fea.Tri6`]</span>
<span class="sd">        :param u: Unit vector defining the direction of the axis</span>
<span class="sd">        :type u: :class:`numpy.ndarray`</span>
<span class="sd">        :param p: Point on the axis</span>
<span class="sd">        :type p: :class:`numpy.ndarray`</span>
<span class="sd">        :return: Force in the top and bottom areas *(f_top, f_bot)*</span>
<span class="sd">        :rtype: tuple(float, float)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialise variables</span>
        <span class="p">(</span><span class="n">f_top</span><span class="p">,</span> <span class="n">f_bot</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ea_top</span><span class="p">,</span> <span class="n">ea_bot</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="n">qx_top</span><span class="p">,</span> <span class="n">qx_bot</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="n">qy_top</span><span class="p">,</span> <span class="n">qy_bot</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># loop through all elements in the mesh</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="c1"># calculate element force and area properties</span>
            <span class="p">(</span><span class="n">f_el</span><span class="p">,</span> <span class="n">ea_el</span><span class="p">,</span> <span class="n">qx_el</span><span class="p">,</span> <span class="n">qy_el</span><span class="p">,</span> <span class="n">is_above</span><span class="p">)</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">plastic_properties</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

            <span class="c1"># assign force and area properties to the top or bottom segments</span>
            <span class="k">if</span> <span class="n">is_above</span><span class="p">:</span>
                <span class="n">f_top</span> <span class="o">+=</span> <span class="n">f_el</span>
                <span class="n">ea_top</span> <span class="o">+=</span> <span class="n">ea_el</span>
                <span class="n">qx_top</span> <span class="o">+=</span> <span class="n">qx_el</span>
                <span class="n">qy_top</span> <span class="o">+=</span> <span class="n">qy_el</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_bot</span> <span class="o">+=</span> <span class="n">f_el</span>
                <span class="n">ea_bot</span> <span class="o">+=</span> <span class="n">ea_el</span>
                <span class="n">qx_bot</span> <span class="o">+=</span> <span class="n">qx_el</span>
                <span class="n">qy_bot</span> <span class="o">+=</span> <span class="n">qy_el</span>

        <span class="c1"># if there are no elements in the top/bottom prevent division by zero N.B. the algorithm</span>
        <span class="c1"># will never converge at this point, this is purely done to ensure a 100% search range</span>
        <span class="k">if</span> <span class="n">ea_top</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ea_top</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ea_bot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ea_bot</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># calculate the centroid of the top and bottom segments and save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_top</span> <span class="o">=</span> <span class="p">[</span><span class="n">qy_top</span> <span class="o">/</span> <span class="n">ea_top</span><span class="p">,</span> <span class="n">qx_top</span> <span class="o">/</span> <span class="n">ea_top</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_bot</span> <span class="o">=</span> <span class="p">[</span><span class="n">qy_bot</span> <span class="o">/</span> <span class="n">ea_bot</span><span class="p">,</span> <span class="n">qx_bot</span> <span class="o">/</span> <span class="n">ea_bot</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_top</span> <span class="o">=</span> <span class="n">f_top</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">f_top</span><span class="p">,</span> <span class="n">f_bot</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlasticSection.create_plastic_mesh"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.create_plastic_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">create_plastic_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_line</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates a triangular mesh of a deep copy of the geometry stored in `self.geometry`.</span>
<span class="sd">        Optionally, a line can be added to the copied geometry, which is defined by a point *p* and</span>
<span class="sd">        a unit vector *u*.</span>

<span class="sd">        :param new_line: A point p and a unit vector u defining a line to add to the mesh</span>
<span class="sd">            (new_line: p -&gt; p + u) [*p*, *u*]</span>
<span class="sd">        :type new_line: list[:class:`numpy.ndarray`, :class:`numpy.ndarray`]</span>
<span class="sd">        :param mesh: Mesh object returned by meshpy</span>
<span class="sd">        :type mesh: :class:`meshpy.triangle.MeshInfo`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># start with the initial geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>

        <span class="c1"># add line at new_line</span>
        <span class="k">if</span> <span class="n">new_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">new_line</span><span class="p">)</span>

            <span class="c1"># fast clean the geometry after adding the line</span>
            <span class="n">clean</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">GeometryCleaner</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">clean</span><span class="o">.</span><span class="n">zip_points</span><span class="p">()</span>
            <span class="n">clean</span><span class="o">.</span><span class="n">remove_zero_length_facets</span><span class="p">()</span>
            <span class="n">clean</span><span class="o">.</span><span class="n">remove_unused_points</span><span class="p">()</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">clean</span><span class="o">.</span><span class="n">geometry</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">geom</span><span class="o">.</span><span class="n">plot_geometry</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># build mesh object</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">MeshInfo</span><span class="p">()</span>  <span class="c1"># create mesh info object</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">set_points</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>  <span class="c1"># set points</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">set_facets</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">facets</span><span class="p">)</span>  <span class="c1"># set facets</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">set_holes</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>  <span class="c1"># set holes</span>

        <span class="c1"># set regions</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">control_points</span><span class="p">))</span>
        <span class="n">region_id</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># initialise region ID variable</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">control_points</span><span class="p">):</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">region_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">region_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">quality_meshing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="PlasticSection.add_line"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.add_line">[docs]</a>    <span class="k">def</span> <span class="nf">add_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a line a geometry object. Finds the intersection points of the line with the</span>
<span class="sd">        current facets and splits the existing facets to accomodate the new line.</span>

<span class="sd">        :param geometry: Cross-section geometry object used to generate the mesh</span>
<span class="sd">        :type geometry: :class:`~sectionproperties.pre.sections.Geometry`</span>
<span class="sd">        :param line: A point p and a unit vector u defining a line to add to the mesh</span>
<span class="sd">            (line: p -&gt; p + u)</span>
<span class="sd">        :type line: list[:class:`numpy.ndarray`, :class:`numpy.ndarray`]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialise intersection points and facet index list</span>
        <span class="n">int_pts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fct_idx</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># get current number of points in the geometry object</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># line: p -&gt; p + r</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># loop through all the facets in the geometry to find intersection pts</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">fct</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">facets</span><span class="p">):</span>
            <span class="c1"># facet: q -&gt; q + s</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">fct</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">fct</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">q</span>

            <span class="c1"># cacluate intersection point between p -&gt; p + r and q -&gt; q + s N.B. make line</span>
            <span class="c1"># p -&gt; p + r inifintely long to find all intersects if the lines are not parallel</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># calculate t and u</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

                <span class="n">new_pt</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">r</span>

                <span class="c1"># if the line lies within q -&gt; q + s and the point hasn&#39;t already been added</span>
                <span class="c1"># (ignore t as it is infinitely long)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_pt</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">int_pts</span><span class="p">]):</span>
                    <span class="n">int_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt</span><span class="p">)</span>
                    <span class="n">fct_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="c1"># if less than 2 intersection points are found, we are at the edge of the section,</span>
        <span class="c1"># therefore no line to add</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">int_pts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># sort intersection points and facet list first by x, then by y</span>
        <span class="n">int_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">int_pts</span><span class="p">)</span>
        <span class="n">idx_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">int_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">int_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">int_pts</span> <span class="o">=</span> <span class="n">int_pts</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>
        <span class="n">fct_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fct_idx</span><span class="p">)[</span><span class="n">idx_sort</span><span class="p">])</span>

        <span class="c1"># add points to the geometry object</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">int_pts</span><span class="p">:</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># add new facets by looping from the second facet index to the end</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fct_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="c1"># get mid-point of proposed new facet</span>
            <span class="n">mid_pt</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">int_pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">int_pts</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># check to see if the mid-point is not in a hole</span>
            <span class="c1"># add the facet</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_within_element</span><span class="p">(</span><span class="n">mid_pt</span><span class="p">):</span>
                <span class="n">geometry</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">num_pts</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_pts</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># rebuild the intersected facet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rebuild_parent_facet</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">num_pts</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># rebuild the first facet the looped skipped</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rebuild_parent_facet</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">fct_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_pts</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># sort list of facet indices (to be removed) in reverse order so as not to comprimise the</span>
        <span class="c1"># indices during deletion</span>
        <span class="n">idx_to_remove</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fct_idx</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx_to_remove</span><span class="p">:</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlasticSection.rebuild_parent_facet"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.rebuild_parent_facet">[docs]</a>    <span class="k">def</span> <span class="nf">rebuild_parent_facet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">fct_idx</span><span class="p">,</span> <span class="n">pt_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Splits and rebuilds a facet at a given point.</span>

<span class="sd">        :param geometry: Cross-section geometry object used to generate the mesh</span>
<span class="sd">        :type geometry: :class:`~sectionproperties.pre.sections.Geometry`</span>
<span class="sd">        :param int fct_idx: Index of the facet to be split</span>
<span class="sd">        :param int pt_idx: Index of the point to insert into the facet</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get current facet</span>
        <span class="n">fct</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">facets</span><span class="p">[</span><span class="n">fct_idx</span><span class="p">]</span>

        <span class="c1"># rebuild facet</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fct</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt_idx</span><span class="p">])</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pt_idx</span><span class="p">,</span> <span class="n">fct</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span></div>

<div class="viewcode-block" id="PlasticSection.point_within_element"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.point_within_element">[docs]</a>    <span class="k">def</span> <span class="nf">point_within_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines whether a point lies within an element in the mesh stored in</span>
<span class="sd">        `self.mesh_elements`.</span>

<span class="sd">        :param pt: Point to check</span>
<span class="sd">        :type pt: :class:`numpy.ndarray`</span>
<span class="sd">        :return: Whether the point lies within an element</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">px</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">py</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># loop through elements in the mesh</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_elements</span><span class="p">:</span>
            <span class="c1"># get coordinates of corner points</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[</span><span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[</span><span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[</span><span class="n">el</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[</span><span class="n">el</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># compute variables alpha, beta and gamma</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">((</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">px</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x3</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">py</span> <span class="o">-</span> <span class="n">y3</span><span class="p">))</span> <span class="o">/</span>
                <span class="p">((</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x3</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y3</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">((</span><span class="n">y3</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">px</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">py</span> <span class="o">-</span> <span class="n">y3</span><span class="p">))</span> <span class="o">/</span>
                <span class="p">((</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x3</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y3</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">-</span> <span class="n">beta</span>

            <span class="c1"># if the point lies within an element</span>
            <span class="k">if</span> <span class="n">alpha</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">beta</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">gamma</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="PlasticSection.plot_mesh"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.PlasticSection.plot_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">plot_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">element_list</span><span class="p">,</span> <span class="n">materials</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Watered down implementation of the CrossSection method to plot the finite element mesh,</span>
<span class="sd">        showing material properties.&quot;&quot;&quot;</span>

        <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">post</span><span class="o">.</span><span class="n">setup_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># plot the mesh</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="n">nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">elements</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                   <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>

        <span class="n">color_array</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">legend_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">materials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># create an array of finite element colours</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">element_list</span><span class="p">:</span>
                <span class="n">color_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>

            <span class="c1"># create a list of unique material legend entries</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">materials</span><span class="p">):</span>
                <span class="c1"># if the material has not be entered yet</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">mat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">materials</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># add the material colour and name to the legend list</span>
                    <span class="n">legend_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">color</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="n">cmap</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">color_array</span><span class="p">)</span>  <span class="c1"># custom colormap</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">color_array</span><span class="p">))</span>  <span class="c1"># indicies of elements</span>

            <span class="c1"># plot the mesh colours</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tripcolor</span><span class="p">(</span><span class="n">nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">elements</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>

            <span class="c1"># display the legend</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center left&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">handles</span><span class="o">=</span><span class="n">legend_list</span><span class="p">)</span>

        <span class="c1"># finish the plot</span>
        <span class="n">post</span><span class="o">.</span><span class="n">finish_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Finite Element Mesh&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="StressPost"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.StressPost">[docs]</a><span class="k">class</span> <span class="nc">StressPost</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for post-processing finite element stress results.</span>

<span class="sd">    A StressPost object is created when a stress analysis is carried out and is returned as an</span>
<span class="sd">    object to allow post-processing of the results. The StressPost object creates a deep copy of</span>
<span class="sd">    the MaterialGroups within the cross-section to allow the calculation of stresses for each</span>
<span class="sd">    material. Methods for post-processing the calculated stresses are provided.</span>

<span class="sd">    :param cross_section: Cross section object for stress calculation</span>
<span class="sd">    :type cross_section: :class:`~sectionproperties.analysis.cross_section.CrossSection`</span>

<span class="sd">    :cvar cross_section: Cross section object for stress calculation</span>
<span class="sd">    :vartype cross_section: :class:`~sectionproperties.analysis.cross_section.CrossSection`</span>
<span class="sd">    :cvar material_groups: A deep copy of the `cross_section` material groups to allow a new stress</span>
<span class="sd">        analysis</span>
<span class="sd">    :vartype material_groups: list[:class:`~sectionproperties.pre.pre.MaterialGroup`]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cross_section</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the StressPost class.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cross_section</span> <span class="o">=</span> <span class="n">cross_section</span>

        <span class="c1"># make a deep copy of the material groups to the StressPost object such that stress results</span>
        <span class="c1"># can be saved to a new material group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cross_section</span><span class="o">.</span><span class="n">material_groups</span><span class="p">)</span>

<div class="viewcode-block" id="StressPost.plot_stress_contour"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_contour">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots filled stress contours over the finite element mesh.</span>

<span class="sd">        :param sigs: List of nodal stress values for each material</span>
<span class="sd">        :type sigs: list[:class:`numpy.ndarray`]</span>
<span class="sd">        :param string title: Plot title</span>
<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create plot and setup the plot</span>
        <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">post</span><span class="o">.</span><span class="n">setup_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span>

        <span class="c1"># plot the finite element mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cross_section</span><span class="o">.</span><span class="n">plot_mesh</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># set up the colormap</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>

        <span class="c1"># create triangulation</span>
        <span class="n">triang</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">Triangulation</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cross_section</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_section</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cross_section</span><span class="o">.</span><span class="n">mesh_elements</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># determine minimum and maximum stress values for the contour list</span>
        <span class="n">sig_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sigs</span><span class="p">])</span>
        <span class="n">sig_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sigs</span><span class="p">])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">sig_min</span><span class="p">,</span> <span class="n">sig_max</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="mi">15</span>
            <span class="n">ticks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ticks</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># plot the filled contour, looping through the materials</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sigs</span><span class="p">):</span>
            <span class="c1"># create and set the mask for the current material</span>
            <span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_section</span><span class="o">.</span><span class="n">elements</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">mask_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">el_ids</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">triang</span><span class="o">.</span><span class="n">set_mask</span><span class="p">(</span><span class="n">mask_array</span><span class="p">)</span>

            <span class="c1"># plot the filled contour</span>
            <span class="n">trictr</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">triang</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>

        <span class="c1"># display the colourbar</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">trictr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Stress&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.4e</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">ticks</span><span class="p">)</span>

        <span class="c1"># TODO: display stress values in the toolbar (format_coord)</span>

        <span class="c1"># finish the plot</span>
        <span class="n">post</span><span class="o">.</span><span class="n">finish_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_vector"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_vector">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigxs</span><span class="p">,</span> <span class="n">sigys</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots stress vectors over the finite element mesh.</span>

<span class="sd">        :param sigxs: List of x-components of the nodal stress values for each material</span>
<span class="sd">        :type sigxs: list[:class:`numpy.ndarray`]</span>
<span class="sd">        :param sigys: List of y-components of the nodal stress values for each material</span>
<span class="sd">        :type sigys: list[:class:`numpy.ndarray`]</span>
<span class="sd">        :param string title: Plot title</span>
<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create plot and setup the plot</span>
        <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">post</span><span class="o">.</span><span class="n">setup_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span>

        <span class="c1"># plot the finite element mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cross_section</span><span class="o">.</span><span class="n">plot_mesh</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># set up the colormap</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>

        <span class="c1"># initialise quiver plot list max scale</span>
        <span class="n">quiv_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_scale</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># plot the vectors</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sigx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sigxs</span><span class="p">):</span>
            <span class="n">sigy</span> <span class="o">=</span> <span class="n">sigys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># scale the colour with respect to the magnitude of the vector</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">sigx</span><span class="p">,</span> <span class="n">sigy</span><span class="p">)</span>

            <span class="n">quiv</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cross_section</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_section</span><span class="o">.</span><span class="n">mesh_nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sigx</span><span class="p">,</span>
                <span class="n">sigy</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span>
            <span class="p">)</span>

            <span class="c1"># get the scale and store the max value</span>
            <span class="n">quiv</span><span class="o">.</span><span class="n">_init</span><span class="p">()</span>
            <span class="n">max_scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_scale</span><span class="p">,</span> <span class="n">quiv</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">quiv_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quiv</span><span class="p">)</span>

            <span class="c1"># update the colormap values</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">c_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">c_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">c_min</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                <span class="n">c_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c_max</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

        <span class="c1"># apply the scale</span>
        <span class="k">for</span> <span class="n">quiv_plot</span> <span class="ow">in</span> <span class="n">quiv_list</span><span class="p">:</span>
            <span class="n">quiv_plot</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">max_scale</span>

        <span class="c1"># apply the colourbar</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">quiv</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Stress&#39;</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="n">v1</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.4e</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># finish the plot</span>
        <span class="n">post</span><span class="o">.</span><span class="n">finish_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.get_stress"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.get_stress">[docs]</a>    <span class="k">def</span> <span class="nf">get_stress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the stresses within each material belonging to the current</span>
<span class="sd">        :class:`~sectionproperties.analysis.cross_section.StressPost` object.</span>

<span class="sd">        :return: A list of dictionaries containing the cross-section stresses for each material.</span>
<span class="sd">        :rtype: list[dict]</span>

<span class="sd">        A dictionary is returned for each material in the cross-section, containing the following</span>
<span class="sd">        keys and values:</span>

<span class="sd">        * *&#39;Material&#39;*: Material name</span>
<span class="sd">        * *&#39;sig_zz_n&#39;*: Normal stress :math:`\sigma_{zz,N}` resulting from the axial load :math:`N`</span>
<span class="sd">        * *&#39;sig_zz_mxx&#39;*: Normal stress :math:`\sigma_{zz,Mxx}` resulting from the bending moment</span>
<span class="sd">          :math:`M_{xx}`</span>
<span class="sd">        * *&#39;sig_zz_myy&#39;*: Normal stress :math:`\sigma_{zz,Myy}` resulting from the bending moment</span>
<span class="sd">          :math:`M_{yy}`</span>
<span class="sd">        * *&#39;sig_zz_m11&#39;*: Normal stress :math:`\sigma_{zz,M11}` resulting from the bending moment</span>
<span class="sd">          :math:`M_{11}`</span>
<span class="sd">        * *&#39;sig_zz_m22&#39;*: Normal stress :math:`\sigma_{zz,M22}` resulting from the bending moment</span>
<span class="sd">          :math:`M_{22}`</span>
<span class="sd">        * *&#39;sig_zz_m&#39;*: Normal stress :math:`\sigma_{zz,\Sigma M}` resulting from all bending</span>
<span class="sd">          moments</span>
<span class="sd">        * *&#39;sig_zx_mzz&#39;*: *x*-component of the shear stress :math:`\sigma_{zx,Mzz}` resulting from</span>
<span class="sd">          the torsion moment</span>
<span class="sd">        * *&#39;sig_zy_mzz&#39;*: *y*-component of the shear stress :math:`\sigma_{zy,Mzz}` resulting from</span>
<span class="sd">          the torsion moment</span>
<span class="sd">        * *&#39;sig_zxy_mzz&#39;*: Resultant shear stress :math:`\sigma_{zxy,Mzz}` resulting from the</span>
<span class="sd">          torsion moment</span>
<span class="sd">        * *&#39;sig_zx_vx&#39;*: *x*-component of the shear stress :math:`\sigma_{zx,Vx}` resulting from</span>
<span class="sd">          the shear force :math:`V_{x}`</span>
<span class="sd">        * *&#39;sig_zy_vx&#39;*: *y*-component of the shear stress :math:`\sigma_{zy,Vx}` resulting from</span>
<span class="sd">          the shear force :math:`V_{x}`</span>
<span class="sd">        * *&#39;sig_zxy_vx&#39;*: Resultant shear stress :math:`\sigma_{zxy,Vx}` resulting from the shear</span>
<span class="sd">          force :math:`V_{x}`</span>
<span class="sd">        * *&#39;sig_zx_vy&#39;*: *x*-component of the shear stress :math:`\sigma_{zx,Vy}` resulting from</span>
<span class="sd">          the shear force :math:`V_{y}`</span>
<span class="sd">        * *&#39;sig_zy_vy&#39;*: *y*-component of the shear stress :math:`\sigma_{zy,Vy}` resulting from</span>
<span class="sd">          the shear force :math:`V_{y}`</span>
<span class="sd">        * *&#39;sig_zxy_vy&#39;*: Resultant shear stress :math:`\sigma_{zxy,Vy}` resulting from the shear</span>
<span class="sd">          force :math:`V_{y}`</span>
<span class="sd">        * *&#39;sig_zx_v&#39;*: *x*-component of the shear stress :math:`\sigma_{zx,\Sigma V}` resulting</span>
<span class="sd">          from all shear forces</span>
<span class="sd">        * *&#39;sig_zy_v&#39;*: *y*-component of the shear stress :math:`\sigma_{zy,\Sigma V}` resulting</span>
<span class="sd">          from all shear forces</span>
<span class="sd">        * *&#39;sig_zxy_v&#39;*: Resultant shear stress :math:`\sigma_{zxy,\Sigma V}` resulting from all</span>
<span class="sd">          shear forces</span>
<span class="sd">        * *&#39;sig_zz&#39;*: Combined normal stress :math:`\sigma_{zz}` resulting from all actions</span>
<span class="sd">        * *&#39;sig_zx&#39;*: *x*-component of the shear stress :math:`\sigma_{zx}` resulting from all</span>
<span class="sd">          actions</span>
<span class="sd">        * *&#39;sig_zy&#39;*: *y*-component of the shear stress :math:`\sigma_{zy}` resulting from all</span>
<span class="sd">          actions</span>
<span class="sd">        * *&#39;sig_zxy&#39;*: Resultant shear stress :math:`\sigma_{zxy}` resulting from all actions</span>
<span class="sd">        * *&#39;sig_vm&#39;*: von Mises stress :math:`\sigma_{vM}` resulting from all actions</span>

<span class="sd">        The following example returns the normal stress within a 150x90x12 UA section resulting</span>
<span class="sd">        from an axial force of 10 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(N=10e3)</span>

<span class="sd">            stresses = stress_post.get_stress()</span>
<span class="sd">            print(&#39;Material: {0}&#39;.format(stresses[0][&#39;Material&#39;]))</span>
<span class="sd">            print(&#39;Axial Stresses: {0}&#39;.format(stresses[0][&#39;sig_zz_n&#39;]))</span>

<span class="sd">            $ Material: default</span>
<span class="sd">            $ Axial Stresses: [3.6402569 3.6402569 3.6402569 ... 3.6402569 3.6402569 3.6402569]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stress</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">stress</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;Material&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s1">&#39;sig_zz_n&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_n</span><span class="p">,</span>
                <span class="s1">&#39;sig_zz_mxx&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_mxx</span><span class="p">,</span>
                <span class="s1">&#39;sig_zz_myy&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_myy</span><span class="p">,</span>
                <span class="s1">&#39;sig_zz_m11&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m11</span><span class="p">,</span>
                <span class="s1">&#39;sig_zz_m22&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m22</span><span class="p">,</span>
                <span class="s1">&#39;sig_zz_m&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m</span><span class="p">,</span>
                <span class="s1">&#39;sig_zx_mzz&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_mzz</span><span class="p">,</span>
                <span class="s1">&#39;sig_zy_mzz&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_mzz</span><span class="p">,</span>
                <span class="s1">&#39;sig_zxy_mzz&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy_mzz</span><span class="p">,</span>
                <span class="s1">&#39;sig_zx_vx&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vx</span><span class="p">,</span>
                <span class="s1">&#39;sig_zy_vx&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vx</span><span class="p">,</span>
                <span class="s1">&#39;sig_zxy_vx&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy_vx</span><span class="p">,</span>
                <span class="s1">&#39;sig_zx_vy&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vy</span><span class="p">,</span>
                <span class="s1">&#39;sig_zy_vy&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vy</span><span class="p">,</span>
                <span class="s1">&#39;sig_zxy_vy&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy_vy</span><span class="p">,</span>
                <span class="s1">&#39;sig_zx_v&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_v</span><span class="p">,</span>
                <span class="s1">&#39;sig_zy_v&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_v</span><span class="p">,</span>
                <span class="s1">&#39;sig_zxy_v&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy_v</span><span class="p">,</span>
                <span class="s1">&#39;sig_zz&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz</span><span class="p">,</span>
                <span class="s1">&#39;sig_zx&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx</span><span class="p">,</span>
                <span class="s1">&#39;sig_zy&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy</span><span class="p">,</span>
                <span class="s1">&#39;sig_zxy&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy</span><span class="p">,</span>
                <span class="s1">&#39;sig_vm&#39;</span><span class="p">:</span> <span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_vm</span>
            <span class="p">})</span>

        <span class="k">return</span> <span class="n">stress</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_n_zz"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_n_zz">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_n_zz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the normal stress :math:`\sigma_{zz,N}` resulting from the</span>
<span class="sd">        axial load :math:`N`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the normal stress within a 150x90x12 UA section resulting from</span>
<span class="sd">        an axial force of 10 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(N=10e3)</span>

<span class="sd">            stress_post.plot_stress_n_zz()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_n_zz.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the axial stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zz,N}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_n</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_mxx_zz"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_mxx_zz">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_mxx_zz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the normal stress :math:`\sigma_{zz,Mxx}` resulting from the</span>
<span class="sd">        bending moment :math:`M_{xx}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the normal stress within a 150x90x12 UA section resulting from</span>
<span class="sd">        a bending moment about the x-axis of 5 kN.m::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mxx=5e6)</span>

<span class="sd">            stress_post.plot_stress_mxx_zz()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_mxx_zz.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the bending stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zz,Mxx}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_mxx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_myy_zz"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_myy_zz">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_myy_zz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the normal stress :math:`\sigma_{zz,Myy}` resulting from the</span>
<span class="sd">        bending moment :math:`M_{yy}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the normal stress within a 150x90x12 UA section resulting from</span>
<span class="sd">        a bending moment about the y-axis of 2 kN.m::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Myy=2e6)</span>

<span class="sd">            stress_post.plot_stress_myy_zz()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_myy_zz.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the bending stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zz,Myy}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_myy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_m11_zz"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_m11_zz">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_m11_zz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the normal stress :math:`\sigma_{zz,M11}` resulting from the</span>
<span class="sd">        bending moment :math:`M_{11}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the normal stress within a 150x90x12 UA section resulting from</span>
<span class="sd">        a bending moment about the 11-axis of 5 kN.m::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(M11=5e6)</span>

<span class="sd">            stress_post.plot_stress_m11_zz()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_m11_zz.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the bending stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zz,M11}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m11</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_m22_zz"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_m22_zz">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_m22_zz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the normal stress :math:`\sigma_{zz,M22}` resulting from the</span>
<span class="sd">        bending moment :math:`M_{22}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the normal stress within a 150x90x12 UA section resulting from</span>
<span class="sd">        a bending moment about the 22-axis of 2 kN.m::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(M22=5e6)</span>

<span class="sd">            stress_post.plot_stress_m22_zz()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_m22_zz.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the bending stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zz,M22}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m22</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_m_zz"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_m_zz">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_m_zz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the normal stress :math:`\sigma_{zz,\Sigma M}` resulting from</span>
<span class="sd">        all bending moments :math:`M_{xx} + M_{yy} + M_{11} + M_{22}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the normal stress within a 150x90x12 UA section resulting from</span>
<span class="sd">        a bending moment about the x-axis of 5 kN.m, a bending moment about the y-axis of 2 kN.m</span>
<span class="sd">        and a bending moment of 3 kN.m about the 11-axis::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mxx=5e6, Myy=2e6, M11=3e6)</span>

<span class="sd">            stress_post.plot_stress_m_zz()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_m_zz.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the bending stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zz,\Sigma M}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz_m</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_mzz_zx"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_mzz_zx">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_mzz_zx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *x*-component of the shear stress :math:`\sigma_{zx,Mzz}`</span>
<span class="sd">        resulting from the torsion moment :math:`M_{zz}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the x-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a torsion moment of 1 kN.m::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mzz=1e6)</span>

<span class="sd">            stress_post.plot_stress_mzz_zx()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_mzz_zx.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zx,Mzz}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_mzz</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_mzz_zy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_mzz_zy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_mzz_zy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *y*-component of the shear stress :math:`\sigma_{zy,Mzz}`</span>
<span class="sd">        resulting from the torsion moment :math:`M_{zz}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the y-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a torsion moment of 1 kN.m::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mzz=1e6)</span>

<span class="sd">            stress_post.plot_stress_mzz_zy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_mzz_zy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zy,Mzz}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_mzz</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_mzz_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_mzz_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_mzz_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the resultant shear stress :math:`\sigma_{zxy,Mzz}` resulting</span>
<span class="sd">        from the torsion moment :math:`M_{zz}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots a contour of the resultant shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a torsion moment of 1 kN.m::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mzz=1e6)</span>

<span class="sd">            stress_post.plot_stress_mzz_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_mzz_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zxy,Mzz}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy_mzz</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_vector_mzz_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_vector_mzz_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_vector_mzz_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a vector plot of the resultant shear stress :math:`\sigma_{zxy,Mzz}` resulting</span>
<span class="sd">        from the torsion moment :math:`M_{zz}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example generates a vector plot of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a torsion moment of 1 kN.m::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mzz=1e6)</span>

<span class="sd">            stress_post.plot_vector_mzz_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/vector_mzz_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Vector plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Vector Plot - $\sigma_{zxy,Mzz}$&#39;</span>
        <span class="n">sigxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_mzz</span><span class="p">)</span>
            <span class="n">sigys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_mzz</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_vector</span><span class="p">(</span><span class="n">sigxs</span><span class="p">,</span> <span class="n">sigys</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_vx_zx"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_vx_zx">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_vx_zx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *x*-component of the shear stress :math:`\sigma_{zx,Vx}`</span>
<span class="sd">        resulting from the shear force :math:`V_{x}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the x-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force in the x-direction of 15 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vx=15e3)</span>

<span class="sd">            stress_post.plot_stress_vx_zx()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_vx_zx.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zx,Vx}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_vx_zy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_vx_zy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_vx_zy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *y*-component of the shear stress :math:`\sigma_{zy,Vx}`</span>
<span class="sd">        resulting from the shear force :math:`V_{x}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the y-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force in the x-direction of 15 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vx=15e3)</span>

<span class="sd">            stress_post.plot_stress_vx_zy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_vx_zy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zy,Vx}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_vx_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_vx_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_vx_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the resultant shear stress :math:`\sigma_{zxy,Vx}` resulting</span>
<span class="sd">        from the shear force :math:`V_{x}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots a contour of the resultant shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force in the x-direction of 15 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vx=15e3)</span>

<span class="sd">            stress_post.plot_stress_vx_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_vx_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zxy,Vx}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy_vx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_vector_vx_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_vector_vx_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_vector_vx_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a vector plot of the resultant shear stress :math:`\sigma_{zxy,Vx}` resulting</span>
<span class="sd">        from the shear force :math:`V_{x}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example generates a vector plot of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force in the x-direction of 15 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vx=15e3)</span>

<span class="sd">            stress_post.plot_vector_vx_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/vector_vx_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Vector plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Vector Plot - $\sigma_{zxy,Vx}$&#39;</span>
        <span class="n">sigxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vx</span><span class="p">)</span>
            <span class="n">sigys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_vector</span><span class="p">(</span><span class="n">sigxs</span><span class="p">,</span> <span class="n">sigys</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_vy_zx"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_vy_zx">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_vy_zx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *x*-component of the shear stress :math:`\sigma_{zx,Vy}`</span>
<span class="sd">        resulting from the shear force :math:`V_{y}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the x-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force in the y-direction of 30 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vy=30e3)</span>

<span class="sd">            stress_post.plot_stress_vy_zx()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_vy_zx.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zx,Vy}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_vy_zy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_vy_zy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_vy_zy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *y*-component of the shear stress :math:`\sigma_{zy,Vy}`</span>
<span class="sd">        resulting from the shear force :math:`V_{y}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the y-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force in the y-direction of 30 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vy=30e3)</span>

<span class="sd">            stress_post.plot_stress_vy_zy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_vy_zy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zy,Vy}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_vy_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_vy_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_vy_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the resultant shear stress :math:`\sigma_{zxy,Vy}` resulting</span>
<span class="sd">        from the shear force :math:`V_{y}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots a contour of the resultant shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force in the y-direction of 30 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vy=30e3)</span>

<span class="sd">            stress_post.plot_stress_vy_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_vy_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zxy,Vy}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy_vy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_vector_vy_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_vector_vy_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_vector_vy_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a vector plot of the resultant shear stress :math:`\sigma_{zxy,Vy}` resulting</span>
<span class="sd">        from the shear force :math:`V_{y}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example generates a vector plot of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force in the y-direction of 30 kN::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vy=30e3)</span>

<span class="sd">            stress_post.plot_vector_vy_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/vector_vy_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Vector plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Vector Plot - $\sigma_{zxy,Vy}$&#39;</span>
        <span class="n">sigxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_vy</span><span class="p">)</span>
            <span class="n">sigys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_vy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_vector</span><span class="p">(</span><span class="n">sigxs</span><span class="p">,</span> <span class="n">sigys</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_v_zx"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_v_zx">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_v_zx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *x*-component of the shear stress</span>
<span class="sd">        :math:`\sigma_{zx,\Sigma V}` resulting from the sum of the applied shear forces</span>
<span class="sd">        :math:`V_{x} + V_{y}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the x-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force of 15 kN in the x-direction and 30 kN in the</span>
<span class="sd">        y-direction::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vx=15e3, Vy=30e3)</span>

<span class="sd">            stress_post.plot_stress_v_zx()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_v_zx.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zx,\Sigma V}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_v</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_v_zy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_v_zy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_v_zy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *y*-component of the shear stress</span>
<span class="sd">        :math:`\sigma_{zy,\Sigma V}` resulting from the sum of the applied shear forces</span>
<span class="sd">        :math:`V_{x} + V_{y}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the y-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force of 15 kN in the x-direction and 30 kN in the</span>
<span class="sd">        y-direction::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vx=15e3, Vy=30e3)</span>

<span class="sd">            stress_post.plot_stress_v_zy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_v_zy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zy,\Sigma V}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_v</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_v_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_v_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_v_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the resultant shear stress</span>
<span class="sd">        :math:`\sigma_{zxy,\Sigma V}` resulting from the sum of the applied shear forces</span>
<span class="sd">        :math:`V_{x} + V_{y}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots a contour of the resultant shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force of 15 kN in the x-direction and 30 kN in the</span>
<span class="sd">        y-direction::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vx=15e3, Vy=30e3)</span>

<span class="sd">            stress_post.plot_stress_v_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_v_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_{zxy,\Sigma V}$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy_v</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_vector_v_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_vector_v_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_vector_v_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a vector plot of the resultant shear stress</span>
<span class="sd">        :math:`\sigma_{zxy,\Sigma V}` resulting from the sum of the  applied shear forces</span>
<span class="sd">        :math:`V_{x} + V_{y}`.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example generates a vector plot of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a shear force of 15 kN in the x-direction and 30 kN in the</span>
<span class="sd">        y-direction::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Vx=15e3, Vy=30e3)</span>

<span class="sd">            stress_post.plot_vector_v_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/vector_v_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Vector plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Vector Plot - $\sigma_{zxy,\Sigma V}$&#39;</span>
        <span class="n">sigxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx_v</span><span class="p">)</span>
            <span class="n">sigys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy_v</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_vector</span><span class="p">(</span><span class="n">sigxs</span><span class="p">,</span> <span class="n">sigys</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_zz"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_zz">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_zz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the combined normal stress :math:`\sigma_{zz}` resulting from</span>
<span class="sd">        all actions.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the normal stress within a 150x90x12 UA section resulting from</span>
<span class="sd">        an axial force of 100 kN, a bending moment about the x-axis of 5 kN.m and a bending moment</span>
<span class="sd">        about the y-axis of 2 kN.m::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(N=100e3, Mxx=5e6, Myy=2e6)</span>

<span class="sd">            stress_post.plot_stress_zz()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_zz.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the normal stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_</span><span class="si">{zz}</span><span class="s1">$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zz</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_zx"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_zx">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_zx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *x*-component of the shear stress :math:`\sigma_{zx}`</span>
<span class="sd">        resulting from all actions.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the x-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a torsion moment of 1 kN.m and a shear force of 30 kN in the</span>
<span class="sd">        y-direction::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mzz=1e6, Vy=30e3)</span>

<span class="sd">            stress_post.plot_stress_zx()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_zx.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_</span><span class="si">{zx}</span><span class="s1">$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_zy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_zy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_zy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the *y*-component of the shear stress :math:`\sigma_{zy}`</span>
<span class="sd">        resulting from all actions.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots the y-component of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a torsion moment of 1 kN.m and a shear force of 30 kN in the</span>
<span class="sd">        y-direction::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mzz=1e6, Vy=30e3)</span>

<span class="sd">            stress_post.plot_stress_zy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_zy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_</span><span class="si">{zy}</span><span class="s1">$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the resultant shear stress :math:`\sigma_{zxy}` resulting</span>
<span class="sd">        from all actions.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots a contour of the resultant shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a torsion moment of 1 kN.m and a shear force of 30 kN in the</span>
<span class="sd">        y-direction::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mzz=1e6, Vy=30e3)</span>

<span class="sd">            stress_post.plot_stress_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_</span><span class="si">{zxy}</span><span class="s1">$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zxy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_vector_zxy"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_vector_zxy">[docs]</a>    <span class="k">def</span> <span class="nf">plot_vector_zxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a vector plot of the resultant shear stress :math:`\sigma_{zxy}` resulting</span>
<span class="sd">        from all actions.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example generates a vector plot of the shear stress within a 150x90x12 UA</span>
<span class="sd">        section resulting from a torsion moment of 1 kN.m and a shear force of 30 kN in the</span>
<span class="sd">        y-direction::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(Mzz=1e6, Vy=30e3)</span>

<span class="sd">            stress_post.plot_vector_zxy()</span>

<span class="sd">        ..  figure:: ../images/stress/vector_zxy.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Vector plot of the shear stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Vector Plot - $\sigma_</span><span class="si">{zxy}</span><span class="s1">$&#39;</span>
        <span class="n">sigxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zx</span><span class="p">)</span>
            <span class="n">sigys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_zy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_vector</span><span class="p">(</span><span class="n">sigxs</span><span class="p">,</span> <span class="n">sigys</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div>

<div class="viewcode-block" id="StressPost.plot_stress_vm"><a class="viewcode-back" href="../../../rst/post.html#sectionproperties.analysis.cross_section.StressPost.plot_stress_vm">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress_vm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a contour plot of the von Mises stress :math:`\sigma_{vM}` resulting from all</span>
<span class="sd">        actions.</span>

<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>

<span class="sd">        The following example plots a contour of the von Mises stress within a 150x90x12 UA section</span>
<span class="sd">        resulting from the following actions:</span>

<span class="sd">        * :math:`N = 50` kN</span>
<span class="sd">        * :math:`M_{xx} = -5` kN.m</span>
<span class="sd">        * :math:`M_{22} = 2.5` kN.m</span>
<span class="sd">        * :math:`M_{zz} = 1.5` kN.m</span>
<span class="sd">        * :math:`V_{x} = 10` kN</span>
<span class="sd">        * :math:`V_{y} = 5` kN</span>

<span class="sd">        ::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>
<span class="sd">            from sectionproperties.analysis.cross_section import CrossSection</span>

<span class="sd">            geometry = sections.AngleSection(d=150, b=90, t=12, r_r=10, r_t=5, n_r=8)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>
<span class="sd">            section = CrossSection(geometry, mesh)</span>

<span class="sd">            section.calculate_geometric_properties()</span>
<span class="sd">            section.calculate_warping_properties()</span>
<span class="sd">            stress_post = section.calculate_stress(</span>
<span class="sd">                N=50e3, Mxx=-5e6, M22=2.5e6, Mzz=0.5e6, Vx=10e3, Vy=5e3</span>
<span class="sd">            )</span>

<span class="sd">            stress_post.plot_stress_vm()</span>

<span class="sd">        ..  figure:: ../images/stress/stress_vm.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Contour plot of the von Mises stress.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Stress Contour Plot - $\sigma_</span><span class="si">{vM}</span><span class="s1">$&#39;</span>
        <span class="n">sigs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">material_groups</span><span class="p">:</span>
            <span class="n">sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">stress_result</span><span class="o">.</span><span class="n">sig_vm</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress_contour</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MaterialGroup"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.MaterialGroup">[docs]</a><span class="k">class</span> <span class="nc">MaterialGroup</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for storing elements of different materials.</span>

<span class="sd">    A MaterialGroup object contains the finite element objects for a specified `material`. The</span>
<span class="sd">    `stress_result` variable provides storage for stresses related each material.</span>

<span class="sd">    :param material: Material object for the current MaterialGroup</span>
<span class="sd">    :type material: :class:`~sectionproperties.pre.pre.Material`</span>
<span class="sd">    :param int num_nods: Number of nodes for the entire cross-section</span>

<span class="sd">    :cvar material: Material object for the current MaterialGroup</span>
<span class="sd">    :vartype material: :class:`~sectionproperties.pre.pre.Material`</span>
<span class="sd">    :cvar stress_result: A StressResult object for saving the stresses of the current material</span>
<span class="sd">    :vartype stress_result: :class:`~sectionproperties.analysis.cross_section.StressResult`</span>
<span class="sd">    :cvar elements: A list of finite element objects that are of the current material type</span>
<span class="sd">    :vartype elements: list[:class:`~sectionproperties.analysis.fea.Tri6`]</span>
<span class="sd">    :cvar el_ids: A list of the element IDs of the elements that are of the current material type</span>
<span class="sd">    :vartype el_ids: list[int]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">material</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the MaterialGroup class.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">material</span> <span class="o">=</span> <span class="n">material</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stress_result</span> <span class="o">=</span> <span class="n">StressResult</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">el_ids</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="MaterialGroup.add_element"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.MaterialGroup.add_element">[docs]</a>    <span class="k">def</span> <span class="nf">add_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an element and its element ID to the MaterialGroup.</span>

<span class="sd">        :param element: Element to add to the MaterialGroup</span>
<span class="sd">        :type element: :class:`~sectionproperties.analysis.fea.Tri6`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># add Tri6 element to the list of elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">el_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">el_id</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="StressResult"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.StressResult">[docs]</a><span class="k">class</span> <span class="nc">StressResult</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for storing a stress result.</span>

<span class="sd">    Provides variables to store the results from a cross-section stress analysis. Also provides a</span>
<span class="sd">    method to calculate combined stresses.</span>

<span class="sd">    :param int num_nodes: Number of nodes in the finite element mesh</span>

<span class="sd">    :cvar sig_zz_n: Normal stress (:math:`\sigma_{zz,N}`) resulting from an axial force</span>
<span class="sd">    :vartype sig_zz_n: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zz_mxx: Normal stress (:math:`\sigma_{zz,Mxx}`) resulting from a bending moment about</span>
<span class="sd">        the xx-axis</span>
<span class="sd">    :vartype sig_zz_mxx: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zz_myy: Normal stress (:math:`\sigma_{zz,Myy}`) resulting from a bending moment about</span>
<span class="sd">        the yy-axis</span>
<span class="sd">    :vartype sig_zz_myy: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zz_m11: Normal stress (:math:`\sigma_{zz,M11}`) resulting from a bending moment about</span>
<span class="sd">        the 11-axis</span>
<span class="sd">    :vartype sig_zz_m11: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zz_m22: Normal stress (:math:`\sigma_{zz,M22}`) resulting from a bending moment about</span>
<span class="sd">        the 22-axis</span>
<span class="sd">    :vartype sig_zz_m22: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zx_mzz: Shear stress (:math:`\sigma_{zx,Mzz}`) resulting from a torsion moment about</span>
<span class="sd">        the zz-axis</span>
<span class="sd">    :vartype sig_zx_mzz: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zy_mzz: Shear stress (:math:`\sigma_{zy,Mzz}`) resulting from a torsion moment about</span>
<span class="sd">        the zz-axis</span>
<span class="sd">    :vartype sig_zy_mzz: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zx_vx: Shear stress (:math:`\sigma_{zx,Vx}`) resulting from a shear force in the</span>
<span class="sd">        x-direction</span>
<span class="sd">    :vartype sig_zx_vx: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zy_vx: Shear stress (:math:`\sigma_{zy,Vx}`) resulting from a shear force in the</span>
<span class="sd">        x-direction</span>
<span class="sd">    :vartype sig_zy_vx: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zx_vy: Shear stress (:math:`\sigma_{zx,Vy}`) resulting from a shear force in the</span>
<span class="sd">        y-direction</span>
<span class="sd">    :vartype sig_zx_vy: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zy_vy: Shear stress (:math:`\sigma_{zy,Vy}`) resulting from a shear force in the</span>
<span class="sd">        y-direction</span>
<span class="sd">    :vartype sig_zy_vy: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zz_m: Normal stress (:math:`\sigma_{zz,\Sigma M}`) resulting from all bending moments</span>
<span class="sd">    :vartype sig_zz_m: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zxy_mzz: Resultant shear stress (:math:`\sigma_{zxy,Mzz}`) resulting from a torsion</span>
<span class="sd">        moment in the zz-direction</span>
<span class="sd">    :vartype sig_zxy_mzz: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zxy_vx: Resultant shear stress (:math:`\sigma_{zxy,Vx}`) resulting from a a shear</span>
<span class="sd">        force in the x-direction</span>
<span class="sd">    :vartype sig_zxy_vx: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zxy_vy: Resultant shear stress (:math:`\sigma_{zxy,Vy}`) resulting from a a shear</span>
<span class="sd">        force in the y-direction</span>
<span class="sd">    :vartype sig_zxy_vy: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zx_v: Shear stress (:math:`\sigma_{zx,\Sigma V}`) resulting from all shear forces</span>
<span class="sd">    :vartype sig_zx_v: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zy_v: Shear stress (:math:`\sigma_{zy,\Sigma V}`) resulting from all shear forces</span>
<span class="sd">    :vartype sig_zy_v: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zxy_v: Resultant shear stress (:math:`\sigma_{zxy,\Sigma V}`) resulting from all</span>
<span class="sd">        shear forces</span>
<span class="sd">    :vartype sig_zxy_v: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zz: Combined normal force (:math:`\sigma_{zz}`) resulting from all actions</span>
<span class="sd">    :vartype sig_zz: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zx: Combined shear stress (:math:`\sigma_{zx}`) resulting from all actions</span>
<span class="sd">    :vartype sig_zx: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zy: Combined shear stress (:math:`\sigma_{zy}`) resulting from all actions</span>
<span class="sd">    :vartype sig_zy: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_zxy: Combined resultant shear stress (:math:`\sigma_{zxy}`) resulting from all</span>
<span class="sd">        actions</span>
<span class="sd">    :vartype sig_zxy: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar sig_vm: von Mises stress (:math:`\sigma_{VM}`) resulting from all actions</span>
<span class="sd">    :vartype sig_vm: :class:`numpy.ndarray`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the StressResult class.&quot;&quot;&quot;</span>

        <span class="c1"># allocate stresses arising directly from actions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_mxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_myy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_m11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_m22</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_mzz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_mzz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_vx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_vx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_vy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_vy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>

        <span class="c1"># allocate combined stresses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy_mzz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy_vx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy_vy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_vm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>

<div class="viewcode-block" id="StressResult.calculate_combined_stresses"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.StressResult.calculate_combined_stresses">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_combined_stresses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the combined cross-section stresses.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_mxx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_myy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_m11</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_m22</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy_mzz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_mzz</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_mzz</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy_vx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_vx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_vx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy_vy</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_vy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_vy</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_vx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_vy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_vx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_vy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy_v</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_v</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_v</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_n</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zz_m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_mzz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zx_v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_mzz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy_v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_zx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zy</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_vm</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_zz</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_zxy</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div></div>


<div class="viewcode-block" id="SectionProperties"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.SectionProperties">[docs]</a><span class="k">class</span> <span class="nc">SectionProperties</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for storing section properties.</span>

<span class="sd">    Stores calculated section properties. Also provides methods to calculate section properties</span>
<span class="sd">    entirely derived from other section properties.</span>

<span class="sd">    :cvar float area: Cross-sectional area</span>
<span class="sd">    :cvar float perimeter: Cross-sectional perimeter</span>
<span class="sd">    :cvar float ea: Modulus weighted area (axial rigidity)</span>
<span class="sd">    :cvar float ga: Modulus weighted product of shear modulus and area</span>
<span class="sd">    :cvar float nu_eff: Effective Poisson&#39;s ratio</span>
<span class="sd">    :cvar float qx: First moment of area about the x-axis</span>
<span class="sd">    :cvar float qy: First moment of area about the y-axis</span>
<span class="sd">    :cvar float ixx_g: Second moment of area about the global x-axis</span>
<span class="sd">    :cvar float iyy_g: Second moment of area about the global y-axis</span>
<span class="sd">    :cvar float ixy_g: Second moment of area about the global xy-axis</span>
<span class="sd">    :cvar float cx: X coordinate of the elastic centroid</span>
<span class="sd">    :cvar float cy: Y coordinate of the elastic centroid</span>
<span class="sd">    :cvar float ixx_c: Second moment of area about the centroidal x-axis</span>
<span class="sd">    :cvar float iyy_c: Second moment of area about the centroidal y-axis</span>
<span class="sd">    :cvar float ixy_c: Second moment of area about the centroidal xy-axis</span>
<span class="sd">    :cvar float zxx_plus: Section modulus about the centroidal x-axis for stresses at the positive</span>
<span class="sd">        extreme value of y</span>
<span class="sd">    :cvar float zxx_minus: Section modulus about the centroidal x-axis for stresses at the negative</span>
<span class="sd">        extreme value of y</span>
<span class="sd">    :cvar float zyy_plus: Section modulus about the centroidal y-axis for stresses at the positive</span>
<span class="sd">        extreme value of x</span>
<span class="sd">    :cvar float zyy_minus: Section modulus about the centroidal y-axis for stresses at the negative</span>
<span class="sd">        extreme value of x</span>
<span class="sd">    :cvar float rx_c: Radius of gyration about the centroidal x-axis.</span>
<span class="sd">    :cvar float ry_c: Radius of gyration about the centroidal y-axis.</span>
<span class="sd">    :cvar float i11_c: Second moment of area about the centroidal 11-axis</span>
<span class="sd">    :cvar float i22_c: Second moment of area about the centroidal 22-axis</span>
<span class="sd">    :cvar float phi: Principal axis angle</span>
<span class="sd">    :cvar float z11_plus: Section modulus about the principal 11-axis for stresses at the positive</span>
<span class="sd">        extreme value of the 22-axis</span>
<span class="sd">    :cvar float z11_minus: Section modulus about the principal 11-axis for stresses at the negative</span>
<span class="sd">        extreme value of the 22-axis</span>
<span class="sd">    :cvar float z22_plus: Section modulus about the principal 22-axis for stresses at the positive</span>
<span class="sd">        extreme value of the 11-axis</span>
<span class="sd">    :cvar float z22_minus: Section modulus about the principal 22-axis for stresses at the negative</span>
<span class="sd">        extreme value of the 11-axis</span>
<span class="sd">    :cvar float r11_c: Radius of gyration about the principal 11-axis.</span>
<span class="sd">    :cvar float r22_c: Radius of gyration about the principal 22-axis.</span>
<span class="sd">    :cvar float j: Torsion constant</span>
<span class="sd">    :cvar omega: Warping function</span>
<span class="sd">    :vartype omega: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar psi_shear: Psi shear function</span>
<span class="sd">    :vartype psi_shear: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar phi_shear: Phi shear function</span>
<span class="sd">    :vartype phi_shear: :class:`numpy.ndarray`</span>
<span class="sd">    :cvar float Delta_s: Shear factor</span>
<span class="sd">    :cvar float x_se: X coordinate of the shear centre (elasticity approach)</span>
<span class="sd">    :cvar float y_se: Y coordinate of the shear centre (elasticity approach)</span>
<span class="sd">    :cvar float x11_se: 11 coordinate of the shear centre (elasticity approach)</span>
<span class="sd">    :cvar float y22_se: 22 coordinate of the shear centre (elasticity approach)</span>
<span class="sd">    :cvar float x_st: X coordinate of the shear centre (Trefftz&#39;s approach)</span>
<span class="sd">    :cvar float y_st: Y coordinate of the shear centre (Trefftz&#39;s approach)</span>
<span class="sd">    :cvar float gamma: Warping constant</span>
<span class="sd">    :cvar float A_sx: Shear area about the x-axis</span>
<span class="sd">    :cvar float A_sy: Shear area about the y-axis</span>
<span class="sd">    :cvar float A_sxy: Shear area about the xy-axis</span>
<span class="sd">    :cvar float A_s11: Shear area about the 11 bending axis</span>
<span class="sd">    :cvar float A_s22: Shear area about the 22 bending axis</span>
<span class="sd">    :cvar float beta_x_plus: Monosymmetry constant for bending about the x-axis with the top flange</span>
<span class="sd">        in compression</span>
<span class="sd">    :cvar float beta_x_minus: Monosymmetry constant for bending about the x-axis with the bottom</span>
<span class="sd">        flange in compression</span>
<span class="sd">    :cvar float beta_y_plus: Monosymmetry constant for bending about the y-axis with the top flange</span>
<span class="sd">        in compression</span>
<span class="sd">    :cvar float beta_y_minus: Monosymmetry constant for bending about the y-axis with the bottom</span>
<span class="sd">        flange in compression</span>
<span class="sd">    :cvar float beta_11_plus: Monosymmetry constant for bending about the 11-axis with the top</span>
<span class="sd">        flange in compression</span>
<span class="sd">    :cvar float beta_11_minus: Monosymmetry constant for bending about the 11-axis with the bottom</span>
<span class="sd">        flange in compression</span>
<span class="sd">    :cvar float beta_22_plus: Monosymmetry constant for bending about the 22-axis with the top</span>
<span class="sd">        flange in compression</span>
<span class="sd">    :cvar float beta_22_minus: Monosymmetry constant for bending about the 22-axis with the bottom</span>
<span class="sd">        flange in compression</span>
<span class="sd">    :cvar float x_pc: X coordinate of the global plastic centroid</span>
<span class="sd">    :cvar float y_pc: Y coordinate of the global plastic centroid</span>
<span class="sd">    :cvar float x11_pc: 11 coordinate of the principal plastic centroid</span>
<span class="sd">    :cvar float y22_pc: 22 coordinate of the principal plastic centroid</span>
<span class="sd">    :cvar float sxx: Plastic section modulus about the centroidal x-axis</span>
<span class="sd">    :cvar float syy: Plastic section modulus about the centroidal y-axis</span>
<span class="sd">    :cvar float sf_xx_plus: Shape factor for bending about the x-axis with respect to the top fibre</span>
<span class="sd">    :cvar float sf_xx_minus: Shape factor for bending about the x-axis with respect to the bottom</span>
<span class="sd">        fibre</span>
<span class="sd">    :cvar float sf_yy_plus: Shape factor for bending about the y-axis with respect to the top fibre</span>
<span class="sd">    :cvar float sf_yy_minus: Shape factor for bending about the y-axis with respect to the bottom</span>
<span class="sd">        fibre</span>
<span class="sd">    :cvar float s11: Plastic section modulus about the 11-axis</span>
<span class="sd">    :cvar float s22: Plastic section modulus about the 22-axis</span>
<span class="sd">    :cvar float sf_11_plus: Shape factor for bending about the 11-axis with respect to the top</span>
<span class="sd">        fibre</span>
<span class="sd">    :cvar float sf_11_minus: Shape factor for bending about the 11-axis with respect to the bottom</span>
<span class="sd">        fibre</span>
<span class="sd">    :cvar float sf_22_plus: Shape factor for bending about the 22-axis with respect to the top</span>
<span class="sd">        fibre</span>
<span class="sd">    :cvar float sf_22_minus: Shape factor for bending about the 22-axis with respect to the bottom</span>
<span class="sd">        fibre</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the SectionProperties class.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ea</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ga</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nu_eff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixx_g</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iyy_g</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixy_g</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zxx_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zxx_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zyy_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zyy_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ry_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i11_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i22_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z11_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z11_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z22_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z22_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r11_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r22_c</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_shear</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_shear</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Delta_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_se</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_se</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x11_se</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y22_se</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_st</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_st</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_sx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_sy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_sxy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_s11</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_s22</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_x_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_x_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_y_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_y_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_11_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_11_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_22_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_22_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_pc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_pc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x11_pc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y22_pc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sxx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf_xx_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf_xx_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf_yy_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf_yy_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s11</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s22</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf_11_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf_11_minus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf_22_plus</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf_22_minus</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SectionProperties.calculate_elastic_centroid"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.SectionProperties.calculate_elastic_centroid">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_elastic_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the elastic centroid based on the cross-section area and first moments of</span>
<span class="sd">        area.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ea</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ea</span></div>

<div class="viewcode-block" id="SectionProperties.calculate_centroidal_properties"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.analysis.cross_section.SectionProperties.calculate_centroidal_properties">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_centroidal_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the geometric section properties about the centroidal and principal axes</span>
<span class="sd">        based on the results about the global axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate second moments of area about the centroidal xy axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixx_g</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ea</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iyy_g</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ea</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixy_g</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">qx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ea</span>

        <span class="c1"># calculate section moduli about the centroidal xy axis</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zxx_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zxx_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ymin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zyy_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zyy_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xmin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cx</span><span class="p">)</span>

        <span class="c1"># calculate radii of gyration about centroidal xy axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rx_c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ea</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ry_c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iyy_c</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ea</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

        <span class="c1"># calculate prinicpal 2nd moments of area about the centroidal xy axis</span>
        <span class="n">Delta</span> <span class="o">=</span> <span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixy_c</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i11_c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i22_c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">iyy_c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">Delta</span>

        <span class="c1"># calculate initial principal axis angle</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">i11_c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">i11_c</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ixx_c</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">i11_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ixy_c</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># calculate section moduli about the principal axis</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cx</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cy</span>
            <span class="c1"># determine the coordinate of the point wrt the principal axis</span>
            <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="n">fea</span><span class="o">.</span><span class="n">principal_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="c1"># initialise min, max variables</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x1max</span> <span class="o">=</span> <span class="n">x1</span>
                <span class="n">x1min</span> <span class="o">=</span> <span class="n">x1</span>
                <span class="n">y2max</span> <span class="o">=</span> <span class="n">y2</span>
                <span class="n">y2min</span> <span class="o">=</span> <span class="n">y2</span>

            <span class="c1"># update the mins and maxs where necessary</span>
            <span class="n">x1max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x1max</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">x1min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x1min</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">y2max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y2max</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>
            <span class="n">y2min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y2min</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>

        <span class="c1"># evaluate principal section moduli</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z11_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i11_c</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y2max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z11_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i11_c</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y2min</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z22_plus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i22_c</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x1max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z22_minus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i22_c</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x1min</span><span class="p">)</span>

        <span class="c1"># calculate radii of gyration about centroidal principal axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r11_c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i11_c</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ea</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r22_c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i22_c</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ea</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robbie van Leeuwen

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>